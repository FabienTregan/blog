= Les microservices sans le hype : qu'est ce que c'est, à quoi ça sert, est ce qu'il m'en faut ?
:icons: font

En 2015 le pic des microservices est atteint : pas une conférence sans un ingénieur de Netflix pour vous vendre du rêve, pas une semaine sans nouveau framework magique pour tout faire sans se poser de question. Un article qui fait le point pour sortir du hype et prendre un peu de recul car tout le monde n'est pas (encore) une startup ou un Géant du Web.

'''

= Les problèmes des gros projets classiques

Des problèmes qu'on connait et pour lesquels on a des recettes, qu'elles soient techniques ou organisationnelles.
Malheureusement ces recettes sont souvent mise en œuvre imparfaitement, et avec le projet qui s'aggrandit au fur et à mesure ça demande de plus en plus de vigilence alors qu'on a tendance à être de moins en moins rigoureux.

== Complexité

Projets ont tendance à toujours croître, et un moment ils deviennent tellement complexes qu'il devient difficile de travailler sur le code.

== Scallabilité horizontale

Rendre scalable un monolithe qui n'a pas été conçu pour demande des interventions qui peuvent être lourdes.

== Fiabilité

Compliqué d'avoir des sytèmes complexes fiables car des erreurs apparaissent dans la multiplications des interactions.
Avoir une architecture applicative solide basé sur des composants logicielle aide beaucoup, mais il est difficile d'être suffisament rigoureux pour

== Technologie

Dans des gros projets il peut être compliqué de faire des évolutions technologiques car on veut garder une cohérence dans le projet et il faut tout faire migrer.
On se prive d'outils spécialisés qui permettent d'etre plus performant pour des cas spécifiques car on cherche des choses qui sont utiles à tout le projet.
Accépter qu'un projets soit multi-technos, voir multi-languages c'est un choix qu'on fait difficilement car on perd une partie des bénéfices escomptés des gros projets (personnes interchangeables, capitalisation).

== Innovation métier et méthodo

Compliqué d'organiser une zone d'inovation dans un gros projet quand le métier veut tester des nouvelles idées.
De même manière difficile de faire de l'agile car ça suppose de pouvoir adapter son orga et ses méthodes de travail.

= C'est quoi les microservices

Petites applis avec chacun un domaine fonctionnel. Chacun est  un projet indépendant avec une pizza-team.

Plutôt que de reposer sur des recettes qu'il faut suivre pour avoir un projet monolithe qui se passe bien, on limite volontairement la taille des projets pour bordder le risque.

Si vous ne comprenez pas pourquoi ils ont choisis d'appeller ça "microservices" c'est que vous avez bien compris, de la même manière ils appellent "monolithes" les systèmes classiques car un terme qui marque.

= Avantages

== Ca tient dans la tête et facile à maintenir

== Evolutions techno

Plus facile d'utiliser des technos différentes.

== Facile à gérer

Pizza team avec un PO.

== Scallabilité horizontable

Plus facile de résoudre des problèmes en refactorant le code ou en le réécrivant complètement.

== Fiabilité

Avec des projets plus petits on a moins d'interférences entre les différentes briques donc moins de bug, et les échanges avec les autres passent par des services formalisés donc pas d'effets de bord non prévus.

== Innovation

Si tout est structuré en services il est facile de démarrer un nuoveau projet en utilisant les données des autres, et si KO on jette.

= Les prérequis et les limites

Ceux qu'on avait déjà dans la SOA classique, mais avec un niveau supplémentaire : avant on pouvait s'en accomoder même si ça grinçait alors que là c'est devenu critique.

== Le système devient distribué

On distribue les état du système entre plusieurs briques, donc soucis de cohérence de données et de transactionalité.

Plus difficile à tester en mode connecté : les tests d'intégration deviennent très compliqués.

== Mauvais plan pour les appels non unitaires

Les appels de services qui font appels à plusieurs domaines demandent de multiplier les appels de services. Ça multiplie les possibilité d'erreurs et ça ajoute les latences.

Au pire ça demande d'ajouter des appels spécifiques (bulk ou custom) et du cache.

== Évolutions transverses

Plus difficile de mettre en œuvre les évolutions transverses : dans un projet tu peux le faire en une fois, là sur plusieurs projets. Ça demande de forcer une synchronization ou de gérer des versions et de la compatibilité.

== Démarrage de projet rapides et allocation de personnes.

Il ne faut pas qu'il y ait trop de coût orga pour créer un nouveau projet : créer les équipes, paperasse, définition de budget ... peut être très coûteux.
Pendant la phase de développement un petit projet est plus sensible aux variations dans le volume de travail alors qu'avec un gros projet on peut réallouer la capacité à faire entre différentes parties, il faut donc pouvoir facilement ajouter ou supprimer des personnes.

== Devops et provisionning

Multiplie les applications et les déploiements, donc il faut un workflow très efficace au niveau outil et process.

== Maturité d'exploitation et monitoring

Beaucoup plus de services avec des dépendances partout ça suppose :

- un très bon monitoring de flux pour pouvoir rapidement savoir où se posent les problèmes
- une grande maturité d'exploitation car ça va multiplier les pannes

== Fiabilité

Systèmes distribués ils y a toute une nouvelle classe d'erreurs qui sont intrinsèquement difficile à résoudre.

== Connaissance métier

Ça tient dans la tête mais on le risque de perte de connaissance est plus élevé quand les gens partent, et problème en cas de mise en pause d'un projet.

== Technos

Risque de technos mal choisies car choix moins stratégique : demande de faire des choix cohérents.
Dans un monolithe on est poussé de faire des migrations régulières alors que dans microservices on peut plus facilement choisir de ne pas le faire, surtout que plus facilement en mode maintenance. La théorie c'est "on jette et on recommence" mais il faut une orga qui accepte que c'est un process normal dans la vie d'un projet et pas le signe d'un échec.

Tendance à avoir moins de réutilisation : permet l'inovation mais donc plus compliqué de gérer les développeurs.

== Micro gestion

Gros projet : plus facile d'avoir une gestion stratégique, le mode microservice avec chaque projet avec un PO ça demande d'être mature dans ses priorisations.

== Innovation

Il faut arriver à arbitrer entre POC et pérénité.

= Est ce qu'il m'en faut

La SOA c'est pour gérer la complexité orga et métier en distribuant les choses. Il faut avoir une douleur forte sur ces aspects, on va diminuer la complexité d'un gros élement sur certains axes en le séparant en plusieurs, mais en échange on aura un surcout à d'autres endroits.

On peut avoir des monolithes bien organisés, scalables ... mais de séparer en plusieurs composants si c'est bien fait ça force les choses à être sous contrôle, si c'est mal fait on va dans le mur.

Il faut être mature sur un certain nombre de choses sinon on court à la catastrophe.

Ne vous dites pas qu'il vous faut des microservices : demandez vous si vous avez ces deux problème, et voyez si c'est bon pour vous.

= Comment j'y vais

Pas de magic bullet.

Monolithe vs. microservices : compliqué de déterminer a priori les limites où il faut découper les microservices, et se trouper est coûteux car il faut faire du refactoring cross-projet.

Cas qui va bien : "2ème système" lors d'une refonte.

Cas classique c'est le monolithe que tu "pèles" des services à l'extérieur en externalisant des partie à la bordure du système : on ne se retrouve pas avec 50 mini-appli mais une appli moyenne avec les choses où c'est trop compliqué et / ou ça ne vaut pas la peine de découper, et quelques micro-servcies qui gravitent atour, et qui vont s'en éloigner avec le temps.


Ça demande d'avoir très bien préparé son code sinon il faut beaucoup détricoter, et ça pose toujours des soucis au niveau des données.
