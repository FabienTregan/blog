= L'architecture microservices sans le hype : qu'est ce que c'est, à quoi ça sert, est ce qu'il m'en faut ?
:icons: font

En 2015 le pic des microservices est atteint : pas une conférence sans un ingénieur de Netflix pour vous vendre du rêve,
pas une semaine sans nouveau framework magique pour tout faire sans se poser de question.

Cet article fait le point sur les aspects architecturaux des microservices qui sont souvent négligés.
Car on oublie trop souvent que choisir un style d'architecture pour un système d'information a des conséquences sur la vie des projets et l'organisation de l'entreprise.

= Pourquoi les microservices : les problèmes des gros projets

Avec le temps et le développement de nouvelles fonctionalités, les projects informatiques ont tendance à grossir.
Un certain nombre de problèmes se développent en même temps que le code s'étend.

== Complexité du code

Avec la quantité de code qui augmente le projet devient de plus en plus complexe : même avec une solide architecture logicielle solide et une organisation en composants les interractions entre les différentes briques augmentent.

Cette complexité a deux désavantages :

=== Évolutivité et fiabilité

Au delà d'une certaine complexité, il est impossible d'avoir en tête un modèle du code avec suffisament de détail. Même avec une base de test solide, il devient plus difficile d'ajouter proprement des nouvelles fonctionalité et de faire des refactoring.

Avec la multiplication des composants et des couches, on retrouve des problématique d'intégration à l'intérieur même du projet.
On a alors deux problèmes :

- Des "rustines" qui contournent les règles qui rendent plus  difficile de prévoir les conséquence d'un appel.
- Les contrats de service à l'intérieur d'un même projet sont moins bien formalisés qu'entre projets, on oublie donc plus facilement des cas limites.

La conséquent est un manque de fiabilité du système.

=== Scallabilité horizontale

Rendre scalable un monolithe qui n'a pas été conçu pour demande des interventions qui peuvent être lourdes
s'il faut modifier des comportements qui sont structurants pour le projet.

== Innovation

Pour mieux capitaliser les investissement et faciliter la gestion des personnes, il est naturel de vouloir avoir une cohérence dans les projets au niveau d'un SI : même manière de travailler, mêmes languages, même framework.

En principe les projets doivent suivre la stratégie générale, mais ont certaine marge de manœuvre en fonction de leur spécificité et peuvent faire preuve d'innovation.

Pour les gros projets, la même tension à lieu à l'intérieur même du projet, l'ensemble du projet faisant office de SI vis-à-vis des différents composants, limitant la capacité d'innovation sur trois aspects :

- Techologique : on préfère les projets mono-technos, et mono-languages, même quand il y a des besoins spécifiques.
- Métier et orga : plus dificile de se ménager des zones d'innovations quand on est dans un groupe plus grand

= L'idée des microservices

Les problèmes qu'on vient de décrire sont connus et on dispose de recettes permettant de limiter les risques, par exemple du côté des pratiques agiles ou de link:http://blog.octo.com/software-craftsmanship-une-culture-a-transmettre/[l'artisanat logiciel].

Malheuresement ces recettes demandent d'être rigoureux en permanence,
et de l'être de plus en plus avec l'augmentation de la taille des projets et le remplacement des personnes.

Elles sont donc souvent mis en œuvre imparfaitement
et le résultat ce sont des projets inmaintenables qu'on traine des années avant de pouvoir les remplacer.

À ce problème, la réponse des microservices est simple et assez radicale : pour éviter d'avoir les problème des gros projets il suffit de n'avoir que des petits projets.

On va donc limiter volontairement la taille des projet à quelques personnes pour avoir des link:http://blog.octo.com/2-pizza-team/[pizza team] d'une taille maximale de 7 personnes tout compris. En découpant au besoin les équipes existantes pour s'y conformer.

Le découpage se faire par domaine métier, en groupant les types de données qui ont des liens fort, et en séparant quand les données sont suffisament indépendantes.

Si vous ne comprenez pas pourquoi cela s'appelle "microservices" c'est normal : il s'agit d'un buzzword. Dans la même veine les applications classiques seront appelés "monolithes" pour mettre en avant ce qu'on leur repproche.

image::microservices.png[]

= Avantages de l'approche microservices

== Complexité

Ça tient dans la tête et facile à maintenir car les tests vont pouvoir valider tous les cas.

=== Scallabilité horizontable

Plus facile de résoudre des problèmes en refactorant le code ou en le réécrivant complètement.

=== Fiabilité

On a explicité les interface donc moins d'interférences entre les différentes briques et donc moins de bug.

De même avec les appels de services on a plus tendance à prendre en compte les cas d'erreurs que dans des appels internes.

== Innovation

- Tech : chaque projet a sa marge de manœuvre
- Métier : Si tout est structuré en services il est facile de démarrer un nouveau projet en utilisant les données des autres et d'expérimenter, et plus facile de décomissionner.
- Orga : avec des petites équipes il est facile d'expérimenter de nouvelles approches

= Les prérequis et les limites

Ceux qu'on avait déjà dans la SOA classique, dont les microservices sont une déclinaisonn.
Mais avec un niveau supplémentaire : avant on pouvait s'en accomoder même si ça grinçait alors que là c'est devenu critique.

== Le système devient distribué

Avec des applications classiques on essaie de faire en sorte d'avoir des états indépendants entre les différentes applications.

Dans le passage au microservices, le système devient distribué, ce qui introduit tout une nouvelle typologie d'erreurs qui sont intrinsèquement difficile à résoudre.

Le cas le plus compliqué est celui des transactions :
il faut alors gérer des transactions link:https://en.wikipedia.org/wiki/Two-phase_commit_protocol[en deux phases] ou gérer des annulations.

Même quand on peut se passer de transaction : on a souvent des références cross-applications, et donc un système de gestion d'évènements asynchrones voire de cache à mettre en œuvre.

Il faut également gérer les cas d'indisponibilités des services externes. On peut limiter les risques avec l'approche "design for failure" mais ça demande d'être très rigoureux et ça ajoute de travail.

Finalement il est plus difficile de tester le système.
Les tests d'intégration deviennent très compliqués du fait de la multiplication des applications : il faut préparer les données, tester les erreurs.

== Services à valeur ajoutée

Même si l'approche REST propose de manipuler des entités simples, on a toujours une proportion d'appels "à valeurs ajoutés" qui qui font appels à plusieurs domaines.

Lorsqu'ils sont placés dans des applications différentes, ça multiplie les cas d'erreurs à gérer, et ça ajoute des latences reseau.

Au pire ça demande d'ajouter des appels spécifiques (bulk ou custom) et du cache.

== Évolutions transverses

Plus difficile de mettre en œuvre les évolutions transverses : dans un projet tu peux le faire en une fois, là sur plusieurs projets indépendants c'est plus compliqués.
Ça demande de forcer une synchronization ou de gérer des versions et de la compatibilité.

Rendu encore plus difficile quand on veut itérer rapidement sur des nouvelles versions de services car ça demande à chacun de se synchronizer en permanence.

Pour garder une certaine souplesse, la solution naturelle est alors d'isoler des grappes de projets des autres en limitant les interconnections entre groupes (pattern link:http://blog.octo.com/services-rest-ne-jetez-pas-la-soa-avec-leau-du-bain/[Royaume-émissaire]).
Le risque est alors d'ajouter une couche de management intermédiaire qui ne soit pas au contact direct des projets.

image::royaumes.png[]

== Démarrage de projet rapides et allocation de personnes.

Il ne faut pas qu'il y ait trop de coût orga pour créer un nouveau projet :
créer les équipes, paperasse, définition de budget ... peut être très coûteux.
Pendant la phase de développement un petit projet est plus sensible aux variations dans le volume de travail
alors qu'avec un gros projet on peut réallouer la capacité à faire entre différentes parties,
il faut donc pouvoir ajouter ou supprimer des personnes sans que ça pose trop de contrainte.

On ne parle pas de pools de développeurs partagés ou de déplacer les personnes comme des pions, mais d'avoir une certaine souplesse.

== Devops et provisionning

On multiplie les applications et donc les déploiements, donc il faut un workflow très efficace au niveau outil et process.

D'autant plus vrai pour les tests et les POC où on veut des environements temporaire sous forme de sandbox.

== Maturité d'exploitation et monitoring

Beaucoup plus de services avec des dépendances partout ça suppose :

- un très bon monitoring de flux pour pouvoir rapidement savoir où se posent les problèmes
- une grande maturité d'exploitation car ça va multiplier les pannes
- un monitoring accessibles aux consommatteurs des services pour qu'ils puissent voir d'où vient la panne quand ça a un impact sur eux

== Technos

Risque de technos mal choisies car choix moins stratégique : il faut quand même faire des choix pérènnes car le but n'est pas de tout jeter au bout de 6 mois : il ne s'agit pas de POC technologiques.

Risque de négliger les bonnes pratiques de dev car il y a moins d'enjeux et moins de risque. C'est vrai que dans un projet plus petit la dette technique coûte moins cher, mais un des objectifs c'est quand même d'être plus réactif.

De plus, si les applications ont des scopes réduits, elles seront régulièrement mises en pause pendant les moments où il n'y a pas d'évolution sur ce domaine précis. Dans ce cas la connaissance se perdra plus facilement.

== Micro gestion

Gros projet : plus facile d'avoir une gestion stratégique, le mode microservice avec chaque projet avec un PO ça demande d'être mature dans ses priorisations.

= Est ce qu'il m'en faut ?

La SOA c'est pour gérer la complexité organisationnelle et métier en distribuant les choses.
Il faut avoir un besoin fort sur ces aspects.
On va diminuer la complexité d'un gros élement sur certains axes en le séparant en plusieurs,
mais en échange on aura un surcoût à d'autres endroits.

On peut avoir des monolithes bien organisés, scalables ... mais ça demande une forte discipline interne.
Séparer en plusieurs composants si c'est bien fait ça force les choses à être sous contrôle, par contre si c'est mal fait ça peut cumuler les inconvénients avec peu d'avantages.

Il faut être mature sur un certain nombre de choses sinon on court à la catastrophe.

Ne vous dites pas qu'il vous faut des microservices : demandez vous si vous avez ces deux problème, et si vous avez bien ces deux problèmes posez vous la question.

= Comment j'y vais

Pas de magic bullet.

== From scracth : difficile

Monolithe vs. microservices : compliqué de déterminer a priori les limites où il faut découper les microservices.
Se tromper est coûteux car il faut faire du refactoring cross-projet.

== Cas favorable : peler un monolithe

Cas classique c'est le monolithe que tu "pèles" des services à l'extérieur en externalisant des partie à la bordure du système : on ne se retrouve pas avec 50 mini-appli mais :

- une appli moyenne avec les choses où c'est trop compliqué et / ou ça ne vaut pas la peine de découper
- quelques micro-service qui gravitent atour, et qui vont s'en éloigner avec le temps.

image::decoupage.png[]

C'est rendu d'autant plus facile que l'application initiale est bien structurée en couche technique et en briques métier et que cette restructuration est respectée, sinon il faut beaucoup détricoter.

Avant toute chose régler les problèmes que va poser la distribution des données : c'est très structurant et ça peut empêcher l'opération.

Pas forcément à sens unique : ne pas hésiter à réintégrer des projets qui ont été sorti ou à en fusionner, en fonction de besoin métier ou archi.

[TIP]
.Liens
====

- link:http://philcalcado.com/2015/09/08/how_we_ended_up_with_microservices.html[How we ended up with microservices] sur l'expérience de SoundCloud
- link:http://sanderhoogendoorn.com/blog/index.php/microservices-the-good-the-bad-and-the-ugly/[Microservices. The good, the bad and the ugly]
- link:http://blog.acolyer.org/2015/09/10/out-of-the-fire-swamp-part-iii-go-with-the-flow/[Out of the Fire Swamp – Part III, Go with the flow] sur les questions de données
- link:https://www.nginx.com/blog/introduction-to-microservices/[Introduction to Microservices] sur le blog de Nginx
- link:http://martinfowler.com/bliki/MonolithFirst.html[MonolithFirst] par Martin Fowler
