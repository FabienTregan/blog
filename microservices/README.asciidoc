= L'architecture microservices sans le hype : qu'est ce que c'est, à quoi ça sert, est ce qu'il m'en faut ?
:icons: font

En 2015 le pic des microservices est atteint :
pas une conférence sans un ingénieur de Netflix pour vous vendre du rêve,
pas une semaine sans nouveau framework magique pour tout faire sans se poser de question.

Cet article fait le point sur les aspects architecturaux des microservices.
S'ils sont moins discutés que les questions d'implémentations ils sont au moins aussi importants,
parce que choisir un style d'architecture pour un système d'information a des conséquences structurantes sur la vie des projets et l'organisation de l'entreprise.

= Pourquoi les microservices : les problèmes des gros projets

L'architecure microservices a été inventée pour résoudre un certain nombre de problèmes causés par les gros projets.

Avec le temps, les projects informatiques ont tendance à grossir : on étend petit à petit les fonctionalités existantes, on en ajoute d'autres, et on supprimer rarement les anciennes.

En même temps que le code et le projet s'étend, un certain nombre de douleurs apparaissent :

== Complexité

Avec la quantité de code qui augmente, le code devient de plus en plus complexe.
Même avec une architecture logicielle solide, les interdépendances entre les différentes briques augmentent avec le temps.

Cette complexité a deux désavantages :

=== Évolutivité et fiabilité

Les nouvelles fontionalités métier deviennent de plus en plus complexes, et les différentes briques ont de plus en plus d'interractions.
On a beau organiser le code en couches et en composants, il y a toujours des cas particuliers et des rustines qui rendent les choses plus floues.

Au delà d'un certain seuil, il devient impossible d'avoir en tête un modèle global du projet.

Même avec une base de tests solide, la multiplications des effets de bord de chaque action rend le système moins fiable, et il devient alors plus difficile d'ajouter proprement des nouvelles fonctionalité et de faire des refactoring.

=== Scallabilité horizontale

Augmenter la scalabilité d'un système peut demander de modifier des éléments structurants du projet.

Plus un projet est gros, plus ces interventions deviennent coûteuses et risquées.

Le risque est alors de se retrouver avec un système qu'il est impossible de faire évoluer pour un nouveau cas d'usage.

== Innovation

=== Innovation technologique

Pour capitaliser les investissements et faciliter la gestion des personnes, il est normal de vouloir avoir une cohérence entre les différentes projets d'une entreprises : même manière de travailler, mêmes languages, même outils.

Chaque projet est invité à suivre des choix transverses, et peut s'en écarter en fonction de ses spécificités, à condition de pouvoir le justifier.

Pour les gros projets, la même tension à lieu à l'intérieur même des projets : pour éviter la fragmentation, chaque évolution technique doit pouvoir être propagée à l'intégralité du code.

Avec le temps les modifications deviennent donc plus coûteuses, et il devient plus difficile d'introduire de nouveaux outils pour des besoins spécifiques.

=== Innovation métier

Pour répondre aux nouveaux besoins métier, il faut être capable de ménager une zone d'innovation à l'intérieur des projets.

Car si certaines nouveautés sont mises en œuvre par de nouveaux projets, la plupart se font sur des projets existant.

Or plus un projet est gros, plus il est critique pour l'entreprise, moins on va prendre de risques de le modifier pour tester de nouveaux produits ou de nouveaux marchés, et petit à petit les enjeux de stabilité vont prendre le pas sur la capacité d'innovation.

= L'idée de l'architecture de microservices

Les problèmes qu'on vient de décrire link:http://www.octo.com/fr/publications/4-une-politique-pour-le-systeme-d-information[sont connus depuis longtemps],
et des outils comme l'agile ou link:http://blog.octo.com/software-craftsmanship-une-culture-a-transmettre/[l'artisanat logiciel] permettent de limiter leur impact.

Malheuresement ces recettes demandent d'être rigoureux en permanence,
et de l'être de plus en plus, au fur à et mesure qu'un projet grossit et que les personnes changent.

Elles sont donc souvent mis en œuvre sur le papier ou imparfaitement
et le résultat ce sont des projets inmaintenables qu'on traine des années avant de les jeter à la poubelle pour les réécrire.

À ce danger, la réponse des microservices est simple et assez radicale :
pour éviter d'avoir les problème des gros projets, il suffit de n'avoir que des petits projets.

On va donc limiter la taille des projet à quelques personnes pour avoir des link:http://blog.octo.com/2-pizza-team/[pizza team] d'une taille maximale de 7 personnes tout compris.
En découpant au besoin les projets et les équipes existantes pour s'y conformer.

Il ne s'agit pas de séparer les gros projets en sous-équipes mais bien de projets _indépendants_ : chacun a son organisation, son calendrier, sa base de code, et ses données.

Les échanges entre les projets se fait par des services, qu'il s'agisse d'appels de services (REST / JSON) ou de messages.

image::microservices.png[]

Le découpage se fait par domaine métier, en groupant les services et les types de données qui ont des liens fort, et en séparant quand ils sont suffisament indépendants.

Si vous ne comprenez pas pourquoi cela s'appelle "microservices" c'est normal :
il s'agit d'un buzzword pour rendre le concept attractif.
Dans la même veine,
les admirateurs de cette approche appellent "monolithes" les applications classiques,
pour mettre en avant leur côté négatif, voir menaçant.

Cette architecture est ainsi à la conflucence de plusieurs mouvements de fond de l'informatique:

- la SOA a mise en avant les avantages de l'approche services
- l'agile et le link:http://blog.octo.com/lean-startup/[lean startup] a fourni les modèles d'organisation des équipes
- l'industrialisation des déploiement et la virtualisation, permet de baisser les coût d'exploitation et de mise en production
- le NoSQL a décrispé les choses du côté de l'intégrité des données

= Avantages de l'approche microservices

= Complexité

== Fiabilité

Contraindre la taille des projets permet de limiter les cas particulier, et comme tout le projet dans la tête, on sait exactement comment tout se comporte.

Comme les échanges avec les autres domaines utilisent des appels de services, les contrats sont formalisés. Il est donc plus facile de prendre en compte toutes les possibilités

Ça tient dans la tête et facile à maintenir car les tests vont pouvoir valider tous les cas.

=== Scallabilité horizontable

Plus facile de résoudre des problèmes en refactorant le code ou en le réécrivant complètement.

=== Fiabilité

On a explicité les interface donc moins d'interférences entre les différentes briques et donc moins de bug.

De même avec les appels de services on a plus tendance à prendre en compte les cas d'erreurs que dans des appels internes.

== Innovation

- Tech : chaque projet a sa marge de manœuvre
- Métier : Si tout est structuré en services il est facile de démarrer un nouveau projet en utilisant les données des autres et d'expérimenter, et plus facile de décomissionner.
- Orga : avec des petites équipes il est facile d'expérimenter de nouvelles approches

= Les prérequis et les limites

Ceux qu'on avait déjà dans la SOA classique, dont les microservices sont une déclinaisonn.
Mais avec un niveau supplémentaire : avant on pouvait s'en accomoder même si ça grinçait alors que là c'est devenu critique.

== Le système devient distribué

Avec des applications classiques on essaie de faire en sorte d'avoir des états indépendants entre les différentes applications.

Dans le passage au microservices, le système devient distribué, ce qui introduit tout une nouvelle typologie d'erreurs qui sont intrinsèquement difficile à résoudre.

Le cas le plus compliqué est celui des transactions :
il faut alors gérer des transactions link:https://en.wikipedia.org/wiki/Two-phase_commit_protocol[en deux phases] ou gérer des annulations.

Même quand on peut se passer de transaction : on a souvent des références cross-applications, et donc un système de gestion d'évènements asynchrones voire de cache à mettre en œuvre.

Il faut également gérer les cas d'indisponibilités des services externes. On peut limiter les risques avec l'approche "design for failure" mais ça demande d'être très rigoureux et ça ajoute de travail.

Finalement il est plus difficile de tester le système.
Les tests d'intégration deviennent très compliqués du fait de la multiplication des applications : il faut préparer les données, tester les erreurs.

== Services à valeur ajoutée

Même si l'approche REST propose de manipuler des entités simples, on a toujours une proportion d'appels "à valeurs ajoutés" qui qui font appels à plusieurs domaines.

Lorsqu'ils sont placés dans des applications différentes, ça multiplie les cas d'erreurs à gérer, et ça ajoute des latences reseau.

Au pire ça demande d'ajouter des appels spécifiques (bulk ou custom) et du cache.

== Évolutions transverses

Plus difficile de mettre en œuvre les évolutions transverses : dans un projet tu peux le faire en une fois, là sur plusieurs projets indépendants c'est plus compliqués.
Ça demande de forcer une synchronization ou de gérer des versions et de la compatibilité.

Rendu encore plus difficile quand on veut itérer rapidement sur des nouvelles versions de services car ça demande à chacun de se synchronizer en permanence.

Pour garder une certaine souplesse, la solution naturelle est alors d'isoler des grappes de projets des autres en limitant les interconnections entre groupes (pattern link:http://blog.octo.com/services-rest-ne-jetez-pas-la-soa-avec-leau-du-bain/[Royaume-émissaire]).
Le risque est alors d'ajouter une couche de management intermédiaire qui ne soit pas au contact direct des projets.

image::royaumes.png[]

== Démarrage de projet rapides et allocation de personnes.

Il ne faut pas qu'il y ait trop de coût orga pour créer un nouveau projet :
créer les équipes, paperasse, définition de budget ... peut être très coûteux.
Pendant la phase de développement un petit projet est plus sensible aux variations dans le volume de travail
alors qu'avec un gros projet on peut réallouer la capacité à faire entre différentes parties,
il faut donc pouvoir ajouter ou supprimer des personnes sans que ça pose trop de contrainte.

On ne parle pas de pools de développeurs partagés ou de déplacer les personnes comme des pions, mais d'avoir une certaine souplesse.

== Devops et provisionning

On multiplie les applications et donc les déploiements, donc il faut un workflow très efficace au niveau outil et process.

D'autant plus vrai pour les tests et les POC où on veut des environements temporaire sous forme de sandbox.

== Maturité d'exploitation et monitoring

Beaucoup plus de services avec des dépendances partout ça suppose :

- un très bon monitoring de flux pour pouvoir rapidement savoir où se posent les problèmes
- une grande maturité d'exploitation car ça va multiplier les pannes
- un monitoring accessibles aux consommatteurs des services pour qu'ils puissent voir d'où vient la panne quand ça a un impact sur eux

== Technos

Risque de technos mal choisies car choix moins stratégique : il faut quand même faire des choix pérènnes car le but n'est pas de tout jeter au bout de 6 mois : il ne s'agit pas de POC technologiques.

Risque de négliger les bonnes pratiques de dev car il y a moins d'enjeux et moins de risque. C'est vrai que dans un projet plus petit la dette technique coûte moins cher, mais un des objectifs c'est quand même d'être plus réactif.

De plus, si les applications ont des scopes réduits, elles seront régulièrement mises en pause pendant les moments où il n'y a pas d'évolution sur ce domaine précis. Dans ce cas la connaissance se perdra plus facilement.

== Micro gestion

Gros projet : plus facile d'avoir une gestion stratégique, le mode microservice avec chaque projet avec un PO ça demande d'être mature dans ses priorisations.

= Est ce qu'il m'en faut ?

La SOA c'est pour gérer la complexité organisationnelle et métier en distribuant les choses.
Il faut avoir un besoin fort sur ces aspects.
On va diminuer la complexité d'un gros élement sur certains axes en le séparant en plusieurs,
mais en échange on aura un surcoût à d'autres endroits.

On peut avoir des monolithes bien organisés, scalables ... mais ça demande une forte discipline interne.
Séparer en plusieurs composants si c'est bien fait ça force les choses à être sous contrôle, par contre si c'est mal fait ça peut cumuler les inconvénients avec peu d'avantages.

Il faut être mature sur un certain nombre de choses sinon on court à la catastrophe.

Ne vous dites pas qu'il vous faut des microservices : demandez vous si vous avez ces deux problème, et si vous avez bien ces deux problèmes posez vous la question.

= Comment j'y vais

Pas de magic bullet.

== From scracth : difficile

Monolithe vs. microservices : compliqué de déterminer a priori les limites où il faut découper les microservices.
Se tromper est coûteux car il faut faire du refactoring cross-projet.

== Cas favorable : peler un monolithe

Cas classique c'est le monolithe que tu "pèles" des services à l'extérieur en externalisant des partie à la bordure du système : on ne se retrouve pas avec 50 mini-appli mais :

- une appli moyenne avec les choses où c'est trop compliqué et / ou ça ne vaut pas la peine de découper
- quelques micro-service qui gravitent atour, et qui vont s'en éloigner avec le temps.

image::decoupage.png[]

C'est rendu d'autant plus facile que l'application initiale est bien structurée en couche technique et en briques métier et que cette restructuration est respectée, sinon il faut beaucoup détricoter.

Avant toute chose régler les problèmes que va poser la distribution des données : c'est très structurant et ça peut empêcher l'opération.

Pas forcément à sens unique : ne pas hésiter à réintégrer des projets qui ont été sorti ou à en fusionner, en fonction de besoin métier ou archi.

[TIP]
.Liens
====

- link:http://philcalcado.com/2015/09/08/how_we_ended_up_with_microservices.html[How we ended up with microservices] sur l'expérience de SoundCloud
- link:http://sanderhoogendoorn.com/blog/index.php/microservices-the-good-the-bad-and-the-ugly/[Microservices. The good, the bad and the ugly]
- link:http://blog.acolyer.org/2015/09/10/out-of-the-fire-swamp-part-iii-go-with-the-flow/[Out of the Fire Swamp – Part III, Go with the flow] sur les questions de données
- link:https://www.nginx.com/blog/introduction-to-microservices/[Introduction to Microservices] sur le blog de Nginx
- link:http://martinfowler.com/bliki/MonolithFirst.html[MonolithFirst] par Martin Fowler
