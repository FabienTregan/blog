= Soon
Julien Kirch
v1.0, 2019-01-01
:article_lang: en

== link:https://queue.acm.org/detail.cfm?id=945134[Debugging in an Asynchronous World]

[quote]
____
Before focusing on testing and debugging asynchronous applications, we must mention a few design principles. And while it has always been true that spending time up front creating a good design results in software that’s easier to test, debug, and maintain, it is even more important in our asynchronous world.

Most people find it challenging to model emergent behavior. It is important to create points of reference by making those aspects of the design more explicit.

One useful technique is the creation of sequence diagrams for various canonical tasks or activities in the system. Sequence diagrams explicitly represent multiple execution streams, so they provide an ideal medium for asking questions like, “What happens if event B occurs before event A?”—even though the diagram may show them occurring in the opposite order. It’s very easy to design a system based on one’s narrow vision of how things should happen. Sequence diagrams make it easier to start understanding what can happen. We have seen a number of situations in which relatively serious potential flaws in a system have been detected and dealt with during design time through this approach.

Another very useful technique is to identify and explicitly code state machines where possible. No matter how they are written, components move from state to state depending on the communications they receive. When code evolves unguided, these state decisions often are distributed throughout the code as collections of apparently unrelated if statements. Without a guiding structure, the state machine that corresponds to the code becomes overly complex and error prone, and eventually the code will not be maintainable.

Viewing components as state machines from the beginning structures their evolution along a path that is easier to understand. It provides a central location that encapsulates behavioral decisions. And, like sequence diagrams, state machines are ideal for considering what-if scenarios such as “What if event A arrives when the machine is in state S1?”
____

[quote]
____
However, systems displaying emergent behavior tend to have idiosyncratic communications mechanisms, and one of the most interesting aspects of creating a framework for your system will be figuring out which interactions to capture and how to automate the capture process.
____

== link:https://medium.freecodecamp.org/optimizing-inefficiency-human-folly-and-the-quest-for-the-worst-sorting-algorithm-c0ba7b32ffd[Optimizing Inefficiency: Human folly and the quest for the worst sorting algorithm]

[quote]
____
The quest to find optimally _inefficient_ algorithms reflects something profound and even beautiful about the nature of computer science itself: inefficiency is apparently literally infinite. When we come up with effective heuristics for a particular problem we are clawing back some hint of a signal from an infinite soup of noise.
____

[quote]
____
What can we learn from optimally inefficient algorithms? I think what we learn is that computer programming is not just a skill. It literally touches problems that have perplexed human beings for generations, not only in the sciences but also in art and music. When, as students, we learn about the time complexity and how to choose the best heuristic for a particular problem, we are quite literally grasping at problems that have perplexed people since long before the first digital computers were invented. And in amongst the soup of noise and inefficiency, there are no doubt further optimizations that will make accessible what was once only accessible via inspiration and genius.
____
