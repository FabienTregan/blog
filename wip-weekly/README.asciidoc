= Links - Soon
Julien Kirch
v1.0, 2019-01-01
:article_lang: en

== link:http://www.nathalielawhead.com/candybox/design-notes-a-bit-on-definition-hell-and-building-an-art-toy[design notes, a bit on definition hell, and building an "`art toy`"…]

[quote]
____
I keep talking about this, but I think it’s really fascinating how computer art tools typically are restricted to trying to simulate the art tools that happen in real life. We get very little expression that’s unique to the digital format. You actually have to work pretty hard in Photoshop to simulate glitch art. Even pixel art isn’t very directly supported (you kind of have to work a little to get that).

So when you’re approaching an art tool and the specific goal is to be unique to digital art… designing that is really fascinating. Even just coming up with concepts of "`Ok, how do you even support glitch art?`" "`How should someone draw with a glitch?`"" is an interesting problem to approach. There’s not defined design language for how you would enable “brokenness” in an art tool.

Brokenness aside, what is unique to computers and how would you properly enable that in an art tool?

Tool design is weirdly a lot like game design. When the tools are very new (unique, and no practical "`art language`" exists for their purpose), you also have to teach people how to use them. They have to be _approachable_ enough for people to feel comfortable to mess around in them. You can’t have any sense of failure or judgement on part of the tool. If things were presented in such a way as there were "`stakes`" involved, or some kind of urgency for efficiency looming over experimental tools, then I think people would be too intimidated to explore them.

Like surrealism, abstraction, or a humorous presentation (environment) for them helps a lot.

The tone a program sets is how people will feel inclined to use it.
____

== link:http://joeduffyblog.com/2016/02/07/the-error-model/[The Error Model]

[quote]
____
My conclusion is that’s why many people in the industry think unchecked exceptions are "`good enough`". They stay out of your way for the common success paths and, because most people don't write robust error handling code in non-systems programs, throwing an exception _usually_ gets you out of a pickle fast. Catching and then proceeding often works too. No harm, no foul. Statistically speaking, programs "`work`".

____