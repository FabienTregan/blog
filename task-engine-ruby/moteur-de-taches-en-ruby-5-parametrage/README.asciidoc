[#MDT-5]
ifeval::["{doctype}" == "book"]
= Partie 5 : paramétrage
endif::[]
ifeval::["{doctype}" != "book"]
= Écrire un moteur de tâches en Ruby partie 5 : paramétrage
endif::[]
:author: Julien Kirch
:revnumber: v0.1
:revdate: 2020-07-12
:article_lang: fr
:article_description: Choisir les tâches à executer et les paramétrer
:article_image: steampunk.jpg
ifndef::source-highlighter[]
:source-highlighter: pygments
:pygments-style: friendly
endif::[]
:mdt: moteur de tâches
:msdt: moteurs de tâches

ifeval::["{doctype}" != "book"]
Ceci est le cinquième article d'une série de XXX décrivant pas à pas comment écrire un {mdt} en Ruby.

Après m'être occupé de link:../moteur-de-taches-en-ruby-4-arret-et-redemarrage[l'arrêt et du redémarrage] je vais m'intéresser maintenant au paramétrage des tâches.
endif::[]

Pour le moment le {mdt} ne sait exécuter qu'un seul type de tâches et n'accepte pas de paramètres, c'était suffisant jusque là mais pour la suite il va devenir nécessaire de le changer.

== Définition de l'API des tâches

Le type de tâche sera défini par le nom de la classe de la tâche qu'il faut lancer, c'est ce que font tous les outils que je connais et je ne vois pas d'autre approche intéressante.

Les paramètres d'exécution des tâches sont sous forme d'une `Hash` qui est à la main des tâches.

Par contre il y a plusieurs choix possibles pour le fonctionnement des tâches, par exemple{nbsp}:

=== Solution 1{nbsp}: singletons

Les tâches peuvent être des singletons qu'on instancie une seule fois par {mdt} et sur lesquelles on appelle une méthode `execute`

[source,ruby]
----
class MyTask
  # Instance is a singleton managed by the engine
  def initialize()
  end

  # @param [Hash] parameters
  def execute(parameters)
  end
end
----

=== Solution 2{nbsp}: `execute` avec paramètres

Les tâches sont instanciées à chaque exécution, pour cela on appelle un constructeur sans paramètre puis une méthode `execute` qui prend en paramètre les paramètres d'exécution

[source,ruby]
----
class MyTask
  def initialize()
  end

  # @param [Hash] parameters
  def execute(parameters)
  end
end
----

=== Solution 3{nbsp}: `execute` sans paramètres

Les tâches sont instanciées à chaque exécution, pour cela on appelle un constructeur qui prend en paramètre les paramètres d'exécution puis une méthode `execute` sans paramètre 

[source,ruby]
----
class MyTask
  # @param [Hash] parameters
  def initialize(parameters)
  end

  def execute()
  end
end
----

=== Solution 4{nbsp}: tout dans le constructeur

Les tâches sont instanciées à chaque exécution, pour cela on appelle un constructeur qui prend en paramètre les paramètres d'exécution qui fait tout le traitement, il n'y a pas de méthode `execute`

[source,ruby]
----
class MyTask
  # @param [Hash] parameters
  def initialize(parameters)
  end
end
----

=== Le choix

La solution 1 a une forme d'élégance mais elle a deux inconvénients{nbsp}:

- si le code de la tâche est un peu complexe et que des sous-méthodes deviennent nécessaires, le fait de ne pas pouvoir utiliser de membre d'instance oblige à passer plus de choses en paramètres, ou de créer des classes ou des structures spécifiques
- elle empêche d'utiliser certains modules qui ajoutent des membres d'instances ou à nouveau elle oblige à créer des classes supplémentaires qui de fait vont remplacer la classe de la tâche

Au final le code va souvent ressembler à{nbsp}:

[source,ruby]
----
class MyTask
  def initialize
  end

  # @param [Hash] parameters
  def execute(parameters)
    MyRealTask.new(parameters)
  end

  class MyRealTask
    # @param [Hash] parameters
    def initialize(parameters)
    end
  end
end
----

Au final il vaut mieux laisser aux tâches la responsabilité d'utiliser elles-mêmes des singletons en interne si c'est nécessaire, et de permettre d'économiser une indirection dans le cas le plus fréquent.

Les autres solutions sont assez ressemblantes, et entre toutes je préfère la solution de "`tout dans le constructeur`" qui a le numéro 4.

Même si c'est celle qui peut sembler le moins "`objet`", dans les autres approches la frontière entre ce qu'il faut mettre dans le constructeur et dans le `execute` n'est pas forcément clair (ce qui peut amener à des discussion stériles), et la séparation en deux méthodes n'apporte rien en terme d'API extérieure.

== Modification de schéma

Je vais ajouter les deux colonnes qui manquent à la table `tasks`.
Je vais les définir comme non nullable pour éviter toute fausse manipulations.
Si une tâche n'a aucun paramètre d'exécution, on utilisera une `Hash` vide plutôt d'un `nil`, cela évite l'ambiguïté entre aucun paramètre d'exécution et une valeur qui manque.

Pour stocker les paramètres d'exécution en utilisant une colonne de type link:https://www.postgresql.org/docs/12/datatype-json.html[`jsonb`] qui permet de stocker des données sous forme de JSON.

Par rapport au fait d'utiliser du JSON stocké dans une colonne de texte, cela coûte un peu plus cher en temps d'exécution (car la base de données doit parser et valider le format), par contre cela peut simplifier les investigation car il est possible de link:https://www.postgresql.org/docs/current/functions-json.html[d'accéder au contenu des valeurs] depuis des requêtes.

