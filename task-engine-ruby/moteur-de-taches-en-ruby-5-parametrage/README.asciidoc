[#MDT-5]
ifeval::["{doctype}" == "book"]
= Partie 5 : paramétrage
endif::[]
ifeval::["{doctype}" != "book"]
= Écrire un moteur de tâches en Ruby partie 5 : paramétrage
endif::[]
:author: Julien Kirch
:revnumber: v0.1
:revdate: 2020-07-12
:article_lang: fr
:article_description: Choisir les tâches à executer et les paramétrer
:article_image: steampunk.jpg
ifndef::source-highlighter[]
:source-highlighter: pygments
:pygments-style: friendly
endif::[]
:mdt: moteur de tâches
:msdt: moteurs de tâches

ifeval::["{doctype}" != "book"]
Ceci est le cinquième article d'une série de XXX décrivant pas à pas comment écrire un {mdt} en Ruby.

Après m'être occupé de link:../moteur-de-taches-en-ruby-4-arret-et-redemarrage[l'arrêt et du redémarrage] je vais m'intéresser maintenant au paramétrage des tâches.
endif::[]

Pour le moment le {mdt} ne sait exécuter qu'un seul type de tâches et n'accepte pas de paramètres, c'était suffisant jusque là mais pour la suite il va devenir nécessaire de le changer.

== Comment paramétrer

Le type de tâche sera défini par le nom de la classe de la tâche qu'il faut lancer, c'est ce que font tous les outils que je connais et je ne vois pas d'autre approche intéressante.

Par contre il y a plusieurs choix possibles pour le fonctionnement des tâches, par exemple{nbsp}:

=== Singletons

Les tâches peuvent être des singletons qu'on instancie une seule fois par {mdt} et sur lesquelles on appelle une méthode `execute`

[source,ruby]
----
class MyTask
  # Instance is a singleton managed by the engine
  def initialize()
  end

  # @param [Hash] parameters
  def execute(parameters)
  end
end
----

=== `execute` avec paramètres

Les tâches sont instanciées à chaque exécution, pour cela on appelle un constructeur sans paramètre puis une méthode `execute` qui prend en paramètre les paramètres d'exécution

[source,ruby]
----
class MyTask
  def initialize()
  end

  # @param [Hash] parameters
  def execute(parameters)
  end
end
----

=== `execute` sans paramètres

Les tâches sont instanciées à chaque exécution, pour cela on appelle un constructeur qui prend en paramètre les paramètres d'exécution puis une méthode `execute` sans paramètre 

[source,ruby]
----
class MyTask
  # @param [Hash] parameters
  def initialize(parameters)
  end

  def execute()
  end
end
----

=== Tout dans le constructeur

Les tâches sont instanciées à chaque exécution, pour cela on appelle un constructeur qui prend en paramètre les paramètres d'exécution qui fait tout le traitement, il n'y a pas de méthode `execute`

[source,ruby]
----
class MyTask
  # @param [Hash] parameters
  def initialize(parameters)
  end
end
----

Je vais choisir la ???? approche.

La première a une forme d'élégance mais elle a deux inconvénients{nbsp}:

- si le code de la tâche est un peu complexe et que des sous-méthodes deviennent nécessaires, le fait de ne pas pouvoir utiliser de membre d'instance oblige à passer plus de choses en paramètres, ou de créer des classes ou des structures spécifiques
- elle empêche d'utiliser certains modules qui ajoutent des membres d'instances ou à nouveau elle oblige à créer des classes supplémentaires qui de fait vont remplacer la classe de la tâche

Au final le code va souvent ressembler à{nbsp}:

[source,ruby]
----
class MyTask
  def initialize
  end

  # @param [Hash] parameters
  def execute(parameters)
    MyRealTask.new(parameters)
  end

  class MyRealTask
    # @param [Hash] parameters
    def initialize(parameters)
    end
  end
end
----

Au final il vaut mieux laisser aux tâches la responsabilité d'utiliser elles-mêmes des singletons en interne si c'est nécessaire, et de permettre d'économiser une indirection dans le cas le plus fréquent.