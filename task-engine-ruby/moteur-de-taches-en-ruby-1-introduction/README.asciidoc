= 1 : Introduction
:mdt: moteur de tâches
:msdt: moteurs de tâches

Un {mdt} est une brique logicielles dont le rôle est d'exécuter de manière asynchrone des tâches qu'on lui fournit. On l'alimente en tâche en ajoutant des éléments dans un tuyau&#8201;—{nbsp}par exemple une file de messages{nbsp}—&#8201;et il les consomme aussi rapidement que possible.

Vous avez par exemple Quartz en Java ou Sidekiq en Ruby.

Leur utilisation est souvent assez simple, du moins si on s'en tient aux fonctionnalités standard, mais ce n'est pas le cas de leur fonctionnement interne.

En effet un {mdt} se doit (en principe) d'être efficace via du parallélisme, de ne pas perdre de tâches qu'on lui fournit, de fournir une gestion d'erreur qui permette d'investiguer les problèmes et un tas d'autres choses.

Ces caractéristiques ne sont pas propres à des {msdt}, au contraire on les retrouve, ou on est sensé les retrouver, dans la majorité des logiciels serveurs et des systèmes (c'est-à-dire de compositions de logiciels).

Elles s'appuient chacune sur des pratiques de conception des logiciels plutôt que sur du code particulièrement complexe, du moins tant qu'on choisi de s'appuyer sur des outils comme des systèmes d'exploitations ou des moteurs de bases de données.

link:https://archiloque.net/blog/comment-se-mettre-a-l-echelle-en-presence-d-erreurs/[Cet article] illustre cette situation dans le domaine de la gestion d'erreur.

Cela signifie que bien comprendre le fonctionnement d'un {mdt} permet de comprendre pourquoi ces caractéristiques sont désirables quand on écrit des logiciels et comment les mettre en œuvre.

Je vous propose donc de décrire pas à pas la construction de ce type d'outil.
À chaque étape, je vais expliquer le besoin auquel répond chaque nouvel élément, et la manière d'y répondre.

Si l'outil résultant ne sera pas aussi complet qu'un "`vrai`" {mdt}, il comportera tous les éléments essentiel qu'on retrouve dans les différents systèmes.

Le code (framework et code d'exemple) sera dans un projet unique et ne sera pas packagé sous forme d'une gem. 

Le stockage des données utilisera PostgreSQL car le fonctionnement des transactions des bases de données SQL sera utile pour gérer la parallélisation, et que PostgreSQL est une base de données très utilisée dans le monde Ruby.