[#MDT-1]
ifeval::["{doctype}" == "book"]
= Partie 1 : introduction
endif::[]
ifeval::["{doctype}" != "book"]
= Écrire un moteur de tâches en Ruby partie 1 : introduction
endif::[]
:author: Julien Kirch
:revnumber: v0.1
:revdate: 2020-07-12
:article_lang: fr
:mdt: moteur de tâches
:msdt: moteurs de tâches
:article_description: De quoi s'agit-il ?
:article_image: steampunk.jpg
ifndef::source-highlighter[]
:source-highlighter: pygments
:pygments-style: friendly
endif::[]

Un {mdt} est une brique logicielles dont le rôle est d'exécuter de manière asynchrone des tâches qu'on lui fournit. On l'alimente en tâche en ajoutant des éléments dans un tuyau&#8201;—{nbsp}par exemple une file de messages{nbsp}—&#8201;et il les consomme aussi rapidement que possible.

Vous avez par exemple Quartz en Java ou Sidekiq en Ruby.

Leur utilisation est souvent assez simple, du moins si on s'en tient aux fonctionnalités standard, mais ce n'est pas le cas de leur fonctionnement interne.

En effet un {mdt} se doit (en principe) d'être efficace via du parallélisme, de ne pas perdre de tâches qu'on lui fournit, de fournir une gestion d'erreur qui permette d'investiguer les problèmes et un tas d'autres choses.

Ces caractéristiques ne sont pas propres à des {msdt}, au contraire on les retrouve, ou on est sensé les retrouver, dans la majorité des logiciels serveurs et des systèmes (c'est-à-dire de compositions de logiciels).

Elles s'appuient chacune sur des pratiques de conception des logiciels plutôt que sur du code particulièrement complexe, du moins tant qu'on choisi de s'appuyer sur des outils comme des systèmes d'exploitations ou des moteurs de bases de données.

link:https://archiloque.net/blog/comment-se-mettre-a-l-echelle-en-presence-d-erreurs/[Cet article] illustre cette situation dans le domaine de la gestion d'erreur.

Cela signifie que bien comprendre le fonctionnement d'un {mdt} permet de comprendre pourquoi ces caractéristiques sont désirables quand on écrit des logiciels et comment les mettre en œuvre.

Je vous propose donc de décrire pas à pas la construction de ce type d'outil.
À chaque étape, je vais expliquer le besoin auquel répond chaque nouvel élément, et la manière d'y répondre.

Si l'outil résultant ne sera pas aussi complet qu'un "`vrai`" {mdt}, il comportera tous les éléments essentiels.

Le code (framework et code d'exemple) sera dans un projet unique et ne sera pas packagé sous forme d'une gem.
Le faire ajouterait pas mal de code et un peu de complexité sans que cela apporte quelque chose.

TIP: Le stockage des données utilisera PostgreSQL car le fonctionnement des transactions des bases de données SQL sera utile pour gérer la parallélisation, et que PostgreSQL fournit un certain nombre de fonctionnalités bien pratiques pour implémenter un {mdt}.

ifeval::["{doctype}" == "book"]
Voila pour l'introduction, dans la partie suivante je vais construire la boucle de traitement qui forme le centre de l'outil.
endif::[]
ifeval::["{doctype}" != "book"]
Voila pour l'introduction, link:moteur-de-taches-en-ruby-2-principe[dans l'article suivant] je vais construire la boucle de traitement qui forme le centre de l'outil.
endif::[]