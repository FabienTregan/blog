= Services REST : ne jetez pas (tout) le SOA avec l'eau du bain
:icons: font

Avec l'arrivée de REST, on a bien envie d'oublier tout ce qu'on faisait avant car c'était forcément moins bien.
Mais, si les technologies ont changé, les bonnes pratiques SOA sont toujours aussi pertinente, et permettent de mettre en œuvre des services qui répondent aux besoins tout en gardant la maitrise de son système d'information.

'''

Avec la mise en œuvre des services RESTful, comme avec toute nouvelle technologie, l'envie est forte de faire table rase du passé et de tout réinventer.

Cependant, nous n'avons pas attendu l'arrivée des architectures REST pour implémenter des services.
Même si parfois les outils n'ont pas été à la hauteur des promesses, certaines bonnes pratiques ont fait leurs preuves.
Pour ceux qui ne s'en souviennent pas, on appelait cela "SOA" pour _Service Oriented Architecture_.

Ces pratiques ont permis de créer des architectures de services qui fonctionnent, et évitent de retomber dans certaines des ornières qui ont valu au SOA sa mauvaise réputation.

== Quèsaco SOA ?

On mélange souvent SOA et SOAP car la première vague de SOA a beaucoup utilisé cette technologie.
Mais il faut bien distinguer les deux car l'approche SOA n'est pas liée à un type de service particulier. Et si SOAP commencer à avoir fait ton temps, SOA est toujours aussi pertinent.

Pour comprendre pourquoi, le mieux est de la voir un peu comme la méthode agile :

SOA n'est pas une solution clé en main mais une grille de lecture et quelques bonnes pratiques apportant des réponses à un certain nombre de besoins.
Ensuite à chacun de choisir son approche, et d'interpréter les pratiques à son environnement.

=== SOA : essentiel pour réussir ses services

Aujourd'hui, les parties techniques des services ne sont plus un problème : les outils pour les développer sont matures et ils permettent de les exploiter facilement (frameworks d'exposition, outils de monitoring, briques d'API management…).

La généralisation de l'usage des services au niveau d'un système d'information implique des enjeux de deux ordres :

- avoir des services qui répondent le mieux aux besoins
- garder la maîtrise de son SI dans la durée

Même si les outils ont changé, les besoins des entreprises en terme d'architectures de services sont restés identiques,
et les patterns d'organisation qui ont fait leurs preuves restent adaptés.
Dans le jargon des "architectes" de systèmes d'information, l'application de ces pratiques fait partie de ce qu'on appelle "l'urbanisation".

Les urbanistes planificateurs des années 2000 qui décidaient de tout sans s'impliquer dans la réalisation ont laissé la place à une approché décentralisée :
une stratégie et des grands principes globaux puis une autonomie des projets.
Cela donne une meilleure flexibilité tout en conservant une cohérence globale

=== SOA c'est pour qui ?

Le SOA vous concerne dès que vous commencez à mettre en place des services.
Même si vous avez déjà de nombreux services, une gouvernance peut être mise en place de façon incrémentale sans avoir à révolutionner votre manière de travailler.

Deux situations rendent ces pratiques vitales :

- de nombreuses applications exposants des services
- un métier riche utilisant des données très structurées et des services complexes

=== Une alternative à l'approche SOA : le modèle contractuel

Certains géants du web utilisent une approche alternative à l'approche "gouvernance" portée par SOA.
Il s'agit d'un modèle plus contractuel, où chaque application est responsable de ses données,
et où les échanges entre applications reposent sur un modèle client-fournisseur.
Dans un environnement rigoureux favorisant une grande autonomie des équipes et où un modèle plus collaborationel n'est pas souhaitable, ce modèle peut fonctionner.
Cependant, notre conviction est qu'il est risqué s'il est mal appliqué,
et qu'il s'adapte mal quand le métier de l'entreprise est complexe. Il est donc à réserver à des cas bien spécifiques.

== Trois patterns SOA

Pour atteindre ces objectifs, voici 3 patterns ciblant les besoins principaux d'une architecture de service :
- développer des services qui répondent le mieux aux besoins de tous
- bien partager les données entre application
- limiter le couplage des services

=== Communauté des consommateurs

Quand une application expose des services, il est important qu'ils soient utilisables par le plus grand nombre de consommateurs différents
L'objectif est d'éviter de développer des services à la demande pour chaque nouveau client, même si chacun d'eux a ses besoins et ses contraintes propres.

Pour ce faire, il faut réunir les consommateurs de chaque ensemble de services pour qu'ils définissent collectivement les contrats de services de l'application qui les fournit.
Cela s'applique en amont lorsqu'il s'agit de créer un nouveau service, puis tout au long de sa vie pour définir de manière collégiale les évolutions avec leur calendrier.

Concrètement, il s'agit d'identifier les différents projets et des porteurs dans chacun d'eux,
puis d'instaurer des échanges entre ces personnes avec des points de rencontres réguliers.
La cible n'est pas de seulement se mettre d'accord sur les besoins, mais de définir ensemble la totalité des contrats de service :
signatures des appels, SLA (dont performance et volumétrie).

Même si les besoins spécifiques d'un consommateur nécessitent la création de services à son seul usage,
il faut que cela reste l'exception,
et qu'aucune demande ne se fasse en direct sans passer par la communauté.
Prioriser les demandes qui bénéficient au maximum de personnes permet d'inciter les récalcitrants à coopérer.

image::communaute.png[]

Dans ce type de fonctionnement, les questions les plus délicates sont celles qui concernent le budget,
lorsqu'il faut par exemple décider quelle(s) clé(s) de répartition utiliser pour partager le coût d'un nouveau service qui profitera à plusieurs projets.
Le mieux est de définir une règle de répartition simple, en considérant que sur le long terme les choses s'équilibreront.

=== Réutilisation des modèles de données

Ensuite, pour améliorer les partages de données entre applications, il faut essayer de factoriser et de réutiliser les modèles de données.

L'objectif est d'éviter que chaque projet ne réinterprète les différents modèles à sa manière, ou les effets "téléphone arabe" quand les données évoluent subrepticement au fur et à mesure qu'elles transitent.

Pour ce faire, chaque type de donnée transverse doit être sous la responsabilité d'une équipe qui en définira le modèle canonique et qui aura à charge de travailler avec les différents projets.
Il s'agit en général du projet producteur ou référentiel de cette donnée.

image::modele.png[]

Ce modèle étant autant métier que technique, les deux compétences doivent être représentées dans l'instance de décision.

Si nécessaire, on pourra s'appuyer sur un dictionnaire de données pour le vocabulaire global à l'entreprise,
à condition de l'utiliser à bon escient et d'éviter de vouloir tout normer.

Les API REST axées sur les ressources rend cette idée beaucoup plus naturelle qu'en SOAP où on avait parfois tendance à définir des types de donnée ad-hoc pour chaque service.

À ce sujet il faut bien préciser que le modèle de donnée dont on parle ici est bien le modèle _d'échange_,
il ne s'agit pas du modèle interne ou même de persistance de chaque application :
utiliser une moulinette pour générer le modèle SQL à partir du modèle d'échange a rarement produit les résultats escomptés !

Du point de vue technique, peu importe que ce modèle soit défini dans un outil de modélisation (_design-first_) ou dans des métadonnées (_code-first_),
l'important est que le résultat soit utilisable facilement par les autres projets.

Sur ce point les outils de modélisation JSON manquent de maturité à ce sujet :
si JSON Schema fournit des syntaxes permettant de partager et d'étendre des modèles,
la spécification manque de clarté et les outils les implémentent rarement et de manière incomplète.
Pour le moment il faut donc étendre les outils existants, ou utiliser les outils JSON s'appuyant sur des XSD.

=== Pattern royaume-émissaire

Fournir un service, c'est se coupler avec les applications qui l'utilisent.
Même si on sait techniquement gérer des versions de services,
multiplier les consommateurs, c'est multiplier les coûts de maintenance ou de migrations et limiter sa capacité d'évolution.

Il est donc nécessaire de cadrer les expositions de services en normant les échanges.

Dans cette optique, le pattern royaume-émissaire propose de séparer le SI en différentes zones,
qui correspondent aux grappes d'applications partageant les mêmes données,
et qui en général recoupent l'organisation de l'entreprise.

Dans un même groupe d'applications (_un royaume_), l'utilisation de services entre applications est libre.
Par contre entre les royaumes, les services _émissaires_ devront être prédéfinis.
Cela permet de conserver une souplesse locale, tout en limitant les couplages globaux.

Les services et les données transitant entre royaumes doivent faire l'objet d'une attention spécifique,
l'objectif étant qu'ils soient plus pérennes que les services standard, car leurs migrations sont plus compliquées.
En pratique, on définit généralement des services spécifiques, distincts des services à usage local.

Pour que ces services répondent au mieux aux besoins, ces services doivent être définis en appliquant le modèle "communauté des consommateurs" en réunissant toutes les parties prenantes.

Ce pattern peut très bien s'accompagner de mesures techniques comme des firewalls ou des proxys ainsi que du monitoring,
pour s'assurer que les règles sont bien respectées.

image::royaume.png[]

Bien que la division du SI en zones y fasse penser, résistez à la tentation d'administrer ces services à l'aide d'un outil d'architecture d'entreprise,
mieux vaut s'appuyer sur les outils de publication d'API en y ajoutant les metadonnées nécessaires.

==== Organiser les expositions de services : un outil pour votre SI et pas une fin en soi

Ce modèle suppose un fonctionnement hiérarchique pour arbitrer et organiser les échanges entre les différentes entités.
Il y a une opposition naturelle entre les demandes locales des projets et les choix globaux pour le bien du système.
La tendance logique est alors que l'instance perde de vue que sa mission est d'aider les projets à mieux travailler ensemble, et bascule dans un mode défensif contre les projets et donc contre le métier.
Pour éviter cela, la recette est toujours la même :
ne pas avoir d'équipe dédiée à cela, mais avoir des décideurs juges et parties en choisissant parmi les projets des personnes d'expérience ayant une vision globale, quitte à les former pour cela.

=== SOA et Open API

Les 3 patterns présentés ici sont décrits dans la perspective de services internes d'une entreprise.

Open API où les services sont exposés sur internet de manière ouverte à tous nécessite d'adapter les pattens. Mais comme Open API est une généralisation de l'approche service, cette adaptation se fait très naturellement :

- Royaume-émissaire va correspondre à la coupure entre services internes et externes.
- La réutilisation des modèles va permettre d'offrir une API consistante à vos différents services (à l'inverse de certains géants du web), même si en interne ils sont issus d'applications totalement différentes.
- La communauté des consommateurs ne regroupera plus tous les consommateurs mais des partenaires identifiés avec qui vous avez tissés des liens. Ces partenaires doivent être représentatif de votre cible d'utilisateurs en terme d'usage et de taille, afin d'augmenter les chances que vos services répondent aux besoin de l'ensemble de vos clients. Vous pouvez ensuite valider ces services en les déployant d'abord pour ces partenaires, et les ouvrir au public dans un second temps après d'éventuels ajustements.

== SOA : tout dépend des personnes

Les technologies de services sont maîtrisées, la difficulté de la mise en place d'une architecture de service est donc avant tout organisationnelle.
L'enjeu est de parvenir à faire travailler pour le bien commun des personnes de groupes différents et dont les intérêts peuvent diverger.

Quand il y a des difficultés, la tentation est toujours là de vouloir reprendre la main en pilotant tout par le haut.
Malheureusement cette solution de facilité mène à un SI mal adapté aux besoins,
voire à l'anarchie quand les applications vont se mettre à contourner les règles.
Il faut donc rester dans la négociation, avec des instances robustes en mesure de trancher les conflits.

'''

[TIP]
.À retenir
====
SOA est une grille de lecture et des bonnes pratiques.

Il vise à permettre à développer des services les plus adaptés tout en gardant la maitrise de son SI.

L'enjeu de ces pratiques n'est pas technique mais organisationnelle,
elles nécessitent de faire travailler ensemble les différents projets.

Trois patterns à mettre en œuvre :

- communauté des consommateurs pour développer des services qui répondent le mieux aux besoins de tous
- réutilisation des modèles de données pour bien partager les données entre application
- royaume-émissaire pour limiter le couplage des services

====
