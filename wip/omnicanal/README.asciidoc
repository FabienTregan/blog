= Balade sur l'omnicanal

Si votre système d'information n'est pas tombé dedans quand il était petit, faire de l'omnicanal est souvent un chantier semé d'embuches et de promesses d'éditeurs.

Cet article se propose de prendre du recul sur les outils pour revenir aux questions de fond qui se cachent derrière.

Il est aussi l'occasion de faire un peu d'histoire des SI pour comprendre comment on est arrivé à la situation actuelle.

== C'est quoi l'omnicanal ?

Un SI omnicanal est un SI qui permet aux différentes personnes qui l'utilisent de passer de manière fluide d'un canal de distribution à un autre.

L'exemple type est de pouvoir commencer à faire une demande de prêt immobilier sur son smartphone, de pouvoir la continuer sur son ordinateur portable une fois chez soi, puis éventuellement de terminer le dossier en se rendant en agence.
Cela ne signifie pas utiliser le même outil dans les trois cas, mais bien d'avoir des outils spécifiques dont lergonomie est adaptée à chaque utilisation, et de pouvoir passer de l'un à l'autre "sans couture", c'est à dire sans avoir à refaire une opération déjà faite comme une saisie de donnée.

En plus des avantages pour les utilisateur·rice·s, nous allons voir que l'omnicanalité a également des avantages IT.

== Pourquoi c'est compliqué ?

Le chantier de transformation omnicanal se comporte de plusieurs évolutions différentes.

Pour comprendre la situation d'ensemble le mieux est de revenir en arrière et dérouler l'historique du SI car c'est lui qui explique la situation actuelle.

Nous allons prendre ici un exemple typique tel qu'on le retrouve chez de nombreux clients, toujours dans le domaine bancaire.

=== Les années 80 : au commencement étaient le mainframe et le backoffice

image::si-mainframe.png[]

Les premières brique du SI se sont construits dans les années 80 sur Mainframe, développées en COBOL ou équivalent.
Ces systèmes historiques peuvent être des développements maison, des progiciels, ou un mélange des deux.

Les écrans permettant d'y accéder sont conçus pour les émployé·e·s et leurs sont réservés.

Les workflow de traitements et les fonctionalités qui sont exposés sont directement calqués sur les écrans et chaque étape du process est persistée dans la base de donnée d'une manière structurée.
Il ne s'agit pas d'un modèle MVC : les définitions des écrans sont en fait imbriquées dans le code de services.

Les bureaux étant fermés la nuit et le week-end, les appels interractifs sont désactivés pendant ces périodes ce qui permet d'executer des traitements de masse ou _batch_.
Ces traitements bénéficient ainsi de l'intégralité de la puissance de calcul du serveur, et le fait d'être les seuls à s'executer leur permet de simplifier leur design, ils peuvent ainsi monopoliser des ressources comme de tables de bases de données sans se soucier du reste du monde.

=== Les années 2000 : l'arrivée du web, le bicanal

Avec l'arrivée du web, il est temps d'ouvrir un site de banque en ligne.

Cela signifie donner accès à des fonctionnalités du Mainframe, mais d'une manière différente de celle qui est utilisée pour le backoffice :

* les écrans doivent être adaptés pour être utilisables par des non-employé·e et sont donc parfois allégés, certains workflow comportent donc plus d'étapes· ;
* certaines options nécessitant la validation d'un·e employé·e empêcheront d'aller jusqu'au bout du traitement à partir du site, cela nécessitera des opérations de backoffice spécifiques.

Le système Mainframe historique est vital pour l'entreprise, et la maîtrise qu'on en a n'est pas toujours satisfaisante : ce patrimoine commence à dater, sans test automatisé (ce qui est normal vu l'époque) avec une documentation souvent lacunaire.

La stratégie choisie est donc souvent de limiter au maximum l'ampleur des modifications sur cette partie du système pour limiter les risques.

L'approche choisie alors consiste à autant que possible exposer les workflows existant - c'est-à-dire ceux du backoffice -  sous formes d'API synchrones, et à développer le site web au dessus de ces API, alors même que les workflows ne sont pas les mêmes.
Les contrats de ces APIs sont donc assez proches des écrans Mainframe pour limiter l'effort à fournir.
Il ne s'agit bien entendu pas d'API REST, mais généralement de messages MQ, voire de wrapping des écrans Mainframe grâce à des outils comme Chrysalis, ou de technologies encore plus exotiques.

Lorsque les deux workflows ne correspondent pas, on aboutit à ce type de situation  :

image::workflow-web.png[]

Il est donc impossible de stocker les résultats des étapes 1A ou 2A dans le Mainframe.
Ils seront donc stockés dans le backend du site web dans une base de donnée séparée.
Cela signifie aussi qu'il faudra dupliquer les contrôles de saisie de ces étapes dans la partie web, pour éviter d'avoir à revenir en arrière dans les écrans du site web.

Suivant les étapes, les données sont donc stockées soit dans le système coeur, soit de manière intermédiaire dans le sous système du site web.

image::workflow-web-base.png[]

En fonction des situations, les points de "rencontre" des workflow sont plus ou moins nombreux.
Le cas extrème est celui ou il existe un seul point de synchronization : la dernière étape du workflow.
Dans cette situation, le site web doit stocker toutes les données intermédiaires, et recoder tous les contrôles de saisie.

image::workflow-web-base-pire.png[]

Dans ce cas les données dans la base du site web qui n'ont pas été déversées dans la base du Mainframe ne sont pas visibles depuis le backoffice, le système est donc bicanal.

Par exemple si vous commencez à souscrire un prêt immobilier sur le site web sans terminer la procédure et que vous vous rendez dans votre agence bancaire, il faudra refaire tout ou partie des opérations.

Par ailleurs les opérations de backoffice spécifiques au site web ainsi que les besoin de support clients nécessitent de développer des écrans spécifiques branchés sur le même backend.

image::si-web.png[]

L'inaccessibilité du cœur système historique pendant la nuit pose aussi problème : il est inconcevable de faire de même pour un site web destiné au grand public.
Il existe de nombreuses manières d'améliorer cette situation, l'approche souvent rencontré consiste à :

. effectuer une copie de certaines données avant de couper le système Mainframe, et s'en servir comme d'un cache en lecture seule accessible pendant la nuit, le cache sera désactivé lorsque les traitements de masses sont terminés ;
. ne pas executer les opérations qui nécessitent des écritures mais les enregistrer sous forme de demandes d'executions dans le backend du site web, et réaliser réellement les traitements le jour suivant à l'ouverture du Mainframe.

Cela rend le système dans son ensemble plus difficile à observer car les données sont distribuées entre les deux sous-systèmes.

Bien entendu, même si la réutilisation de fonctionalités existantes est privilégiée, certains besoins du site web nécessitent de développer des APIs spécifiques dans le cœur métier.

Ces points d'entrée sont là pour suppléer aux limites de l'existant et pas pour le remplacer, ils sont donc pas pensé pour servir de base à la création d'une API complète alternative.

=== Aujourd'hui : le mobile et les partenaires

L'arrivée du mobile pourrait signifier la mise en place d'une tricanalité.
Mais les besoins mobiles sont souvent suffisament proches des besoins web pour qu'ils s'appuient sur les mêmes systèmes.
Dans quelques situations il peut être nécessaire de stocker des données intermédiaires sur les terminaux, mais il ne s'agit pas d'un vrai troisième canal.

Les écrans de backoffice ont souvent été remplacés par des technologies web, mais en conservant les mêmes workflows, le backend du nouveau backoffice ne stockant donc pas de données.

En revanche la banque a noué des partenariats, par exemple en marque blanche.
Ces partenaires peuvent par exemple vendre des assurances ou des prêts de la banque dans un package lorsque vous achetez un de leur produits.

Les process nécessaire aux partenaires sont aussi différent du process historique que du process web, le système devient donc souvent tricanal.

image::si-partenaires.png[]

Pour rester lisible, le schéma ne contient pas les backoffice dédiés aux canaux web et partenaires mais ils existent bel et bien, une personne du support peut donc avoir à jongler avec trois backoffices différents.

Le canal partenaire ne pose pas le même problème que le canal web.
En effet un client qui commence à souscrire une assurance en marque blanche en achetant un bien voudra rarement conclure la transaction dans votre agence.
En revanche la multiplication des canaux rend la maintenance du système plus complexequand on veut modifier un des workflows centraux qui sont exposés aux autres cannaux ou changer une des règles de gestion dupliquée à plusieurs endroits.

Certains des besoins partenaires se rapprochent des besoins du site web client, il arrive donc qu'une partie du code soit partagée entre les deux. Cela évite des redéveloppements mais rend encore le système plus difficile à observer.

image::si-partenaires2.png[]

== Que faut-il pour avoir un SI omnicanal ?

Les problèmes causés par l'omnicanal et les limites des SI correspondants nous donnent les informations nécessaire pour dresser le plan d'un SI omnicanal.

Avant de rentrer dans le détail, il faut préciser qu'un système omnicanal ne signifie pas un système unique du haut en bas pour tous les canaux mais un système cœur permettant de répondre aux besoins de l'omnicanal sur lequel viendront se brancher les différents canaux.

La différence avec un système multicanal est bien la capacité de passer d'un canal à l'autre, pas le fait d'avoir un système unique.

Ainsi vous n'exposerez pas forcément les mêmes services ou les mêmes technologies pour votre application mobiles et pour vos partenaires.
Vous aurez donc un système coeur sur lequel viendront se greffer votre canal mobile, votre canal partenaire…

=== Des processus métier indépendants des canaux

Les workflows étant différent d'un canal à l'autre, l'omnicanalité nécessite de concevoir des processus métier qui soient adaptables aux différents canaux.

Cela signifie qu'il ne faut pas penser son processus en terme d'étapes qui ont la granularité d'un écran mais en terme de macro-étapes avec une taille plus importantes, ce qui donnera à chaque canal les marges de manœuvres dont il a besoin.

Par exemple souscrire un crédit peut se décomposer en 3 macro-étapes :

- renseigner des informations personnelles et faire des simulations de crédit jusqu'à obtenir une offre satisfaisante ;
- valider une demande de crédit en saisissant des informations supplémentaires ;
- traiter la demande dans le backoffice pour la valider ou la rejeter.

=== Un système de stockage

Les données doivent être stockés dans un système indépendant des canaux.

Comme les saisies d'informations peuvent se faire dans des ordres différents d'un canal à l'autre, on peut souvent moins s'appuyer sur des contraintes d'intégrités que dans un système monocanal.

Par exemple un·e client·e pourra peut-être créer un compte sans fournir immediatement son nom ou son adresse.

=== Des règles métier de validation

Dans un système historique, les services métier étant adossés aux écrans, chacun comportait les règles métiers correspondant permettant de valider les informations saisies dans le formulaire.

Dans un système omnicanal ce n'est plus possible car chaque canal peut concevoir son parcours.

Cela signifie que les règles de validation seront sous deux formes :

. dans le système central, des règles de validations seront placées au niveau de chaque macro-étape ;
. les canaux doivent implémenter ces mêmes règles au niveau de chaque écran ou de chaque service exposé pour êytre en mesure de remonter des erreurs au plus près.

Cela nécessite de bien documenter les règles.

=== Des services facilement utilisables et composables

Ce sont les services sur lesquels seront construits les canaux.

C'est souvent l'étape la plus difficile.

En effet, composer des services pour de l'omnicanal signifie de bien maîtriser les dépendances entre les différents services pour donner des libertés aux différents canaux.

=== Les canaux

C'est la partie spécifique à chaque canal.

L'objectif est que cette partie du SI ne stocke pas d'information.
En effet comme nous l'avons vue plus haut, toute information stockée au niveau d'un canal va créer un silotage.

L'omnicanalité rend la conception des canaux plus difficiles car ils doivent prendre en compte le fait qu'un processus peut avoir été démarrer dans un autre canal ayant un workflow différent.

Par exemple certains des champs de saisies auront peut-être déjà être remplis et pas d'autres.

Il faut qu'il puisse déterminer comment effectuer la reprise du traitement dans de bonnes conditions.

Cela demande une conception rigoureuse ainsi qu'une bonne couverture de tests.

=== Faire vivre le système

La dernière pierre de l'omnicanal est la capacité à le faire vivre.

En effet les canaux sont fortements couplés au système cœur, ils devront donc être modifiés de manière coordonnée.

Ce couplage est un effet direct de l'omnicanalité : c'est elle qui permet de passer d'un canal à l'autre.
Le modèle de canaux découplés est celui du multicanal.

Votre organisation doit donc être adapté à cette contrainte.

== Comment y aller ?

Maintenant que nous savons en quoi devrait consister un système omnicanal, reste à étudier les trajectoires pour l'atteindre.

=== Situation de départ

Le cœur métier contient trois éléments qui ont de la valeur :
- les règles de validation
- les règles de traitements
- l'interconnection avec le reste du SI, mais si pas toujours satisfaisant

Deux choses non satisfaisantes :
- règles d'intégrité des données alignées avec le process historique
- process hardcodé

Stratégies possibles :

=== Peut-on se passer d'un BPM pour implémenter de l'omnicanal ?

Je n'ai pas mis la partie implémentation du workflow dans les choses difficiles.

Un BPM est plutôt un antipattern ici: faut lui exposer des services qu'il comprend, et lui même expose des services qui ne seront pas forcément ceux qui seront pas forcément adaptés aux consommateurs.

[NOTE]
====
TODO : Schéma avec exemple d'un BPM
====

Si vous le voulez vous pouvez utiliser un moteur de workflow léger, mais autant que possible c'est bien de garder la main sur le code "métier".

=== Tout recoder

Si tu peux ça peut etre cool, par contre projet stratégique très risqué.

=== Rendre le cœur métier historique omnicanal

Projet dont le risque dépend de la maîtrise que vous avez du bousin

=== Ajouter une couche omnicanal

C'est la solution la plus légère, on construit une surcouche, soit from scratch soit en partant d'un des backend existant.

Ça va demander de la duplication d'une partie du cœur métier plus importante que ce que vous avez maintenant.

Ça va demander de modifier les services exposés par le cœur métier.

Ensuite on migre les consommateurs vers cette couche.

Puis on peut commencer à remonter du métier et à dégonfler le cœur métier.

== Conclusion

Omnicanal c'est quelque chose de structurant pour le SI, chantier de longue haleine.

En fait l'omnicanal ça consiste à a

La difficulté est côté métier et côté existant.