= Découplage, découplage, découplage !

En informatique on adore le découplage : quel bonheur ce serait d'avoir des morceaux de systèmes évoluant librement chacun dans leur coin.

image::640px-4_Kittens.jpg[title="Un SI découplé c'est presque aussi bien qu'un SI composé de chatons, photo par Pieter Lanser en CC"]

Il y malheureusement deux ombres à ce tableau idyllique :

- le découplage présente des avantages mais aussi des inconvénients ;
- il n'existe pas _un_ découplage mais _des_ découplages, qui ont chacun leurs caractéristiques propres, parler de _découplage_ sans préciser duquel il s'agit c'est donc prendre le risque de ne pas se comprendre et de faire de mauvais choix.

== Un exemple simple de découplage

Dans l'architecture logicielle, un exemple très simple de découplage est la link:https://fr.wikipedia.org/wiki/Programmation_structurée[programmation structurée].
Il s'agissait de l'idée révolutionnaire d'encapsuler son code dans des modules — fonctions ou procédures — link:http://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf[plutôt que d'utiliser des goto].

Encapsuler du code dans des sous-routine exposée par des APIs formalisées plutôt qu'une masse de code informe, a permis d'améliorer la lisibilité des programmes et la qualité des développements.

Cet exemple a toutes les caractéristiques qu'on retrouvera dans les cas de découplage au niveau du SI :

- un _besoin_ : améliorer la lisibilité et la qualité du code ;
- un _moyen_ : des nouvelles syntaxes spécifiques ;
- un _inconvénient_ : une baisse notable de performance avec les ordinateurs et les compilateurs de cette époque, au point qu'utiliser des fonctions a longtemps été une pratique controversée.

== Les trois types de découplage de SI

À l'échelle d'un SI, il existe trois grands types de découplage :

image::venn.png[title=Les 3 types de découplages qui nous intéressent]

- le découplage de temporalité : quand l'exécution d'une fonctionnalité se fait plus tard de manière asynchrone ;
- le découplage de localisation : quand l'exécution d'une fonctionnalité se fait ailleurs ;
- le découplage de format : quand l'exécution d'une fonctionnalité passe par l'utilisation d'un contrat d'interface stable.

Ils ont des zones de recouvrement mais sont différents.

== Le découplage de format

C'est celui auquel on pense le plus souvent quand on parle de découplage dans le domaine du SI.
Il est fondamental dans une organisation d'une certaine taille car il répond aux _besoins_ de :
- maîtriser les conséquences d'une modification d'une partie du système :
- permettre à différentes équipes de manière indépendante en limitant les efforts de coordination.

Le _moyen_ est de définir certains contrats d'exposition comme étant stables et utilisable à l'extérieur, à l'opposé de contrats "à usage internes" qui ne font pas l'objet de ces garanties.

L'_inconvénient_ est le surcoût créé par l'effort de formalisation, et le risque si ce découplage est mal fait :
en effet le  prérequis pour réaliser ce découpage est que les fonctionnalités à exposer soient matures et évoluent peu, ou évoluent d'une manière qui ne demandent pas de faire évoluer le format d'exposition.
Si les fonctionnalités que vous voulez exposer ne sont pas encore bien maîtrisées, vous risquez d'exposer une link:https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/[mauvaise interface].
Dans ce cas le surcoût de mise en place et de maintien du format pourra être plus important que le gain qu'il apporte, chaque changement entraine des coûts et/ou des délais : communication, tests d'intégration, gestion de compatibilité …

L'utilisation de bonne pratiques et d'outils peut faciliter la définition d'interfaces, mais l'essentiel de la complexité pour exposer des API stables reste une question de connaissance métier et de maturité.

Les bénéfices d'un découplage de format se font sentir même entre sous-modules d'une même application car il permet de rendre le code plus lisible et de limiter les besoins de refactoring lors des évolutions.

Rappelez-vous cependant qu'un découplage de format n'est presque jamais total mais qu'au mieux il s'agit d'un couplage faible : avec le temps tous les services évoluent, et donc aussi leurs contrats.

== Le découplage de localisation

Il est à la base de l'informatique distribuée : il répond au _besoin_ de pouvoir accéder à une fonctionnalité distante sans avoir à connaître précisément le ou les dispositifs en charge de cette fonctionnalité. Cela permet de remplacer, de déplacer, d'ajouter ou de supprimer les machines qui rendent cette fonctionnalité  de manière transparente pour l'appelant.

Le _moyen_ est la mise en place d'une couche d'indirection entre les systèmes comme un DNS : au lieu d'accéder à un système directement, on passe par un nom logique intermédiaire.

Cela couvre les différents types de services distribués comme CORBA, SOAP ou REST, mais aussi les bases de données non locales et les systèmes de fichiers distants.

Un découplage de localisation sans découplage de format peut être utile à l'intérieur d'un même système car il permet de déployer séparément différents composants et de pouvoir gérer la résilience.

L'_inconvénient_ du découplage de localisation est le surcoût en complexité pour suivre et débuguer les traitements, temps de calcul et en temps entrainé par la sérialisation et le cas échéant par le transfert réseau.

Ainsi si votre besoin est un découplage de format et pas un découplage de localisation, travailler sur des modules d'un même applicatif est une stratégie tout à fait valide.

Cependant, le cas le plus courant, qui correspond à ce qu'on entend généralement quand on parle de découplage, correspond à un découplage de localisation et de format.
C'est lui qui permet à des équipes de travailler et de déployer leurs composants en encadrant et en limitant les dépendances.

La méprise la plus courante sur le découplage consiste à penser qu'un découplage de localisation entraîne nécessairement un découplage de format.
Il est vrai qu'exposer des fonctionnalités via des services force à définir un contrat de service, autrement dit une interface formelle, mais rien ne garantit que ce contrat de service permette par lui-même un réel découplage.
C'est l'erreur classique des SI de services mis en œuvre sans gouvernance.

== Le découplage de temporalité

Il s'agit d'exécuter un traitement plus tard de manière asynchrone.
Il se fait souvent au _moyen_ de files de message, d'échanges de fichiers, un d'une base de données.

Il permet d'adresser deux _besoins_ :

- rendre plus rapidement la main à l'appelant en remettant à plus tard une partie des traitements, ce qui améliore le temps de réponse pour le système appelant ;
- permettre facilement de gérer les pics de charge, tant que l'outil en charge de gérer les demandes d'exécution en attente n'est pas submergé.

Il a trois _inconvénients_ majeurs :

- il faut être certain de ne pas perdre de demande de traitements, et de ne pas en traiter en double (ou s'arranger pour que ça n'entraîne pas de conséquences néfastes) ;
- il rend plus difficile la gestion des erreurs et de la transactionalité ;
- il rend plus difficile le monitoring du système, nécessitant souvent la mise en place d'outils link:https://blog.octo.com/present-et-avenir-du-monitoring-de-flux/[de monitoring de flux].

Un découplage de temporalité sans découplage de format rend plus complexes les montées de versions.
En effet il faut alors gérer la compatibilité entre les versions, ou attendre que les demandes en cours soient traitées avant de migrer l'ensemble du système.
Ceci-dit, lorsque l'asynchronisme est utilisé à l'intérieur d'une seule et même application, cette approche peut être la bonne car elle évite d'avoir à se préoccuper de la gestion de compatibilité.

La mise en place d'un découplage de temporalité passe la plupart des cas par l'utilisation d'un outil tiers externe à l'application (file de message, base de données …).
Suivant son implémentation et sa configuration, cet outil peut fournir une forme "naturelle" de découplage de localisation.
Si dans ce cas elle est facile à mettre en œuvre, cela ne veut pas dire qu'elle est gratuite car le surcoût en complexité est bien là.

== Pour conclure

À travers les trois types de découplages et leurs intersections, nous avons vu que découpler n'est pas une fin en soi mais bien un moyen de répondre à certains besoins, ce moyen ayant aussi des inconvénients, notamment des effets de bords à l'endroit où le découplage prend place.
Nous avons aussi vu que d'accumuler les découplages c'était cumuler les avantages mais aussi les inconvénients.

La partie la plus difficile, et qui ne peut être résumée dans un article, c'est de déterminer comment découpler et à quel endroit en fonction des besoins à satisfaire : cela fait link:http://web.mit.edu/Saltzer/www/publications/endtoend/endtoend.pdf[plus de 30 ans] que la question est ouverte.
Si ajouter une certaine quantité de découplage est nécessaire dans les grands systèmes, mal s'y prendre même parfois au désastre.

P.S. : J'ai eu l'idée de cet article après avoir lu link:http://programmingisterrible.com/post/162346490883/how-do-you-cut-a-monolith-in-half[ce texte] qui est une très bonne analyse de l'utilisation de middleware de message pour gérer des tâches asynchrones.
