= Gérer les évolutions des services dans votre SI

== On parle de quoi

Sous-titre "Versionner les services dans votre SI ça ne veut pas dire modifier une configuration de /v1/ à /v2/"

=== Services à l'intérieur d'un SI

Consommateur et producteur à l'intérieur

Gestion des évolutions : on ne parle pas de comment designer vos services : n'explique pas comment faire du REST

Exposer un service c'est un contrat avec un engagement

=== Objectif d'une bonne gestion

* Pouvoir introduire de nouvelles versions pour répondre aux nouvelles demandes
* Décomissionner les anciennes versions
* Un pur sujet de management de SI
* Sujet très compliqué, peu s'en sortent bien
* Pas de silver bullet où de pattern qu'il suffit de dérouler : quelques pratiques à éviter, et beaucoup de choses à décider pour vous

=== On va parler de mots qui fâchent : gouvernance, planning, budget

`Mettre des exemples`

== Généralités

=== Différence entre modèle "vendeur" et modèle "acheteur"

* En interne : les clients demandent (acheteurs)
* En public : on propose un service aux clients (vendeur)
* En interne : on est sur les deux
** Dans le cas de projets de tailles équivalentes, si pas d'énorme projet qui écrase tout
** Important : connaitre ses consommateurs
* Partenaires : souvent entre les deux, voire encore plus compliqué qu'en interne

=== On parle beaucoup des géants du web mais ils ne sont pas le bon exemple pour les API internes

* Ils parlent peu de ce sujet : plutôt API publiques et implémentation
* Différence dans la complexité du produits entre les géant du web et certains de nos clients : beaucoup plus de dépendances sur des choses plus complexes

=== Différences entre API externes et internes

* Contractualisation beaucoup plus faible
** Un DSI  va faire un optimum global
** En général : engagement moral, pas de pénalité en cas de soucis
*** Au pire on négocie une extension de budget
** En général en interne, si un consommateur n'est pas prêt, on ne va pas le débrancher

== Principes

=== Il faut décider qui décide et comment on décide : DSI, instance de gouvernance ...

* Pas subir la non décision
* Axe décisions : optimum global / privilégier certains projets / ... : arbitrer
* Ça peut dépendre des projets (pas forcément une règle unique), et changer dans la vie des projets
* Ce qu'il faut éviter c'est le flou : une mauvaise stratégie c'est mieux qu'une stratégie floue
* Penser aux projets en TMA

=== Deux forces opposées

* Minimum de changement de versions pour ceux que les nouvelles fonctionnalités n'intéresse pas
* Beaucoup de changements de versions pour ceux que ça intéresse
* Les projets peuvent basculer de l'un à l'autre

== Ce qu'il faut exposer, ou pas

=== Plus on expose plus on créé d'adhérence

* Moins on expose moins on en créé

=== N'exposez pas tout par défaut (toutes les données, tous les champs) : faite le en progressif

=== Limiter les consommateurs tant que votre API n'est pas sèche

=== Faites attention quand vous exposer les données que vous même consommez ou vous créez des cascades de dépendances

* Si j'utilise les données de l'appli A, et même si je dois les stocker, je ne les republie pas, sinon je dois changer les services que j'expose quand A change les siens, ou alors je créé une divergence

=== Royaume émissaire

* Certaines données ont vocation à rester dans une certaine zone métier, ne les déversez pas dans tout le SI

=== Ne pas lier l'exposition avec la représentation interne
* On est capable de ne pas changer l'API même si l'interne n'évolue pas

=== Importance de savoir qui utilise quoi : il faut du monitoring

image::zones.png[title="Les zones de services"]

== Comment exposer

=== Nombre de versions
* Arbitrage entre travail pour le producteur et pour les consommateurs
* Deux (idéal) ou trois versions en parallèle
** Chevauchement temporaire entre deux version (on attend entre la sortie de la N+1 et le décomissionnement de la N-1) : permet de sauter une version sur deux pour les consommateurs

image::versions.png[title="Un exemple de gestion de version"]

=== Quand et quoi communiquer

* Cas idéal : définir le contrat en commnun
* Au minimum : communiquer dès que l'interface a été définie
* Contrat d'API : interface  + données d'exemples + mocks
** Mocks des consommateurs pour tester
** S'outiller (swagger)

=== Compatibilité gérée par l'API Management ou l'ESB

* Pas magique : on change de version majeure c'est qu'on change le comportement métier
* Code métier dans un middleware qui est souvent géré par une équipe qui ne connait pas le métier
* L'équipe du middleware devient le goulot d'étranglement pour les projets qui veulent évoluer

=== Changements rétro-compatibles qui devraient être "transparents" pour éviter une montée de version
* Peut être une bonne idée
* Peut être dangereux quand on le pousse trop loin : risque de tordre les contrats
** Si tu as peur de changer le contrat, c'est qu'il y a problème
* Demande de très bien communiquer

== À quel rythme ?

Une fois qu'on sait comment faire, la prochaine étape est le "quand ?".

Tout d'abord il n'y a pas de solution miracle valable dans tous les cas.
En fonction de votre organisation, il est même possible qu'il n'y ait pas de solution unique qui convienne pour vous.
D'une part la solution la plus adaptée dépend d'un projet à l'autre, et varie dans la vie des projets, d'autre part il s'agit d'un choix qui n'a pas d'impact global au niveau du SI.
Il est donc possible de déléguer cette décision au niveau du projet, c'est à dire par le groupe formé par le projet qui expose les services et les consommateurs de ses différents services.

Il y a deux stratégies possibles :

=== Rythme cadencé

Il s'agit de prévoir les évolution de services à un rythme régulier "tous les X", en général tous les X mois.
Ce rythme ne correspond pas au rythme de release du projet : il peut livrer régulièrement sans modifier les services qu'il expose.
Par ailleurs il s'agit de cadencer la possibilité de faire évoluer les services : ce n'est pas parce qu'on a réservé un créneau qu'il faut forcément s'en servir. S'il n'y a rien à changer alors on le passe.

Cette possibilité est plus contraignante pour le projet qui expose, mais la prévisibilité permet aux consommateurs de s'organiser, voire de provisionner les budget de migrations.

Elle est par exemple la plus indiquée dans un contexte non agile où on préfère la prévisibilité à la vitesse.

=== Rythme opportuniste

Dans cette stratégie on fait évoluer le service quand on en a besoin.

Il ne s'agit pas de le faire à l'arrache : il faut bien entendu anticiper les modifications, et laisser aux consommateurs le temps de migrer : on ne dégrade pas la qualité sous prétexte qu'on est plus adaptable.

Mais plutôt que de prévoir des créneaux à l'avance, on préfère le faire en cas de besoin.

Cette approche convient le mieux en début et en fin de projet :

- au début les changements sont les fréquents, pouvoir agir à la demande est plus pratique ;
- en fin de projet lorsque les choses se sont stabilisées, les modifications deviennent occasionnels.

=== Majeur et mineur

Il est possible de mixer les deux approches :
- une approche cadencée pour les versions majeures;
- une approche opportuniste pour les versions mineures.

Ainsi on anticipe les changements bloquants, et on peut fournir au plus tôt les changements transparents.

=== Royaume / émissaire

Le cas du royaume émissaire va complexifier le tableau : les services qui restent à l'intérieur d'une même zone du SI vont avoir tendance à bouger plus rapidement que les services entre zones.
On peut donc avoir une politique différente pour les deux types de services.

Les projets à l'intérieur d'une même zone ayant naturellement tendance à bouger ensemble, suivant que les évolutions du métier porte sur l'un puis l'autre sujet, ils vont probablement adopter un rythme similaire.

== Si un projet client ne peut pas évoluer

Il s'agit d'une question qui ne se poserait pas dans un monde parfait, mais qui en pratique arrive régulièrement : que faire si un projet ne peut pas évoluer et que la solution la plus évidente serait de conserver pour une version de vos service pour lui ?

En anticipant sur la partie suivante, nous allons parler budget.

Avant de choisir cette solution, il faut se rappeler que ce type de compatibilité a un prix.
Ce prix ne se solde pas en une fois mais il s'agit d'un surcoût qui s'ajoute à chaque évolution pour maintenir la rétro-compatibilité.
Par ailleurs ce prix va augmenter au fur et à mesure que la version gelée s'écarte de la version standard et que la rétro-compatibilité devient de plus en plus complexe.

Ce prix est de trois ordres :

- en argent pour le temps passé ;
- en complexité dans le code pour gérer la compatibilité ;
- en motivation pour les développeurs qui doivent prendre en compte cette contrainte lors de chaque évolution.

La seule solution viable, si on veut conserver une rétro-compatibilité pour un consommateur c'est ce que ce soit lui qui finance ce budget.
Cette approche a trois avantages :

- Elle est dissuasive car les projets sont incités à migre ;
- Elle est équitable car c'est le demandeur qui paie ;
- Elle va dans le bon sens car, avec le prix qui va augmenter avec le temps, il y a l'espoir qu'à un certain moment le consommateur saute le pas et se décide à migrer.

Le dernier avantage ne devrait avoir à s'appliquer car, dans un monde idéal, lorsqu'on décide de maintenir une compatibilité c'est pour un temps limité et qui devrait être fixé dès le début.
Dans les fait lorsqu'un projet décroche une telle exception il est tentant de jouer les prolongation, l'augmentation du prix est donc là pour contrebalancer cette tendance.

Ne pas faire payer le consommateur revient à donner une prime à ceux qui ne jouent pas le jeux : si vous ne migrez pas, non seulement vous n'avez plus à vous embêter, mais en plus vous ne payer rien !

=== Il ne doit en rester qu'un

Si malgré tout vous faites le choix de garder une version pour un consommateur, il est très important de tout faire pour faire migrer tous les autres.
En effet une fois que l'exception sera connue, d'autres vont être tentés de s'engouffrer dans la brèche qui vient d'être ouverte et de rester sur la même version.
Économiquement cette approche est attirante car le prix de la maintenance est alors réparti entre tous les projets, à la limite un projet qui voudrait arrêter de migrer aurait même intérêt à en convaincre d'autres pour diviser sa note.

Mais cette approche est très dangereuse : plus il y a de consommateurs bloqués sur une version, plus il y a de chances que vous ayant à maintenir cette version longtemps, voire indéfiniment.

C'est l'un où des cas où la gouvernance stratégique a sa place : car l'optimisation globale du SI s'oppose directement à des solutions opportunistes.

== Budget

Une fois toutes les bonnes résolutions prises, reste une question, probablement la plus importante : qui paie ?

Comme dans certains des autres sujets traités, il n'y a pas de réponse qui convienne dans tous les cas.
La différence ici c'est qu'il vaut peut-être mieux choisir une même approche pour tous les projets pour limiter le nombre de fois où on rouvre ce débat.
Les prises de décisions sur les questions de budgets étant extrêmement difficiles, cela permet de limiter les conflits, même si à chaque cycle budgétaire la tentation est grande de tout remettre en cause.

=== Budget des consommateurs

Quand un consommateur de service a besoin de nouvelles fonctionnalités il n'aura pas de soucis à financer la migration vers la nouvelle version d'une API qui va lui fournir ce dont il a besoin.

Les questions de budget se posent quand le consommateur est satisfait de ce qu'il a déjà et qu'il faut migrer à la version suivante.
Le problème se plus particulièrement pour les projets qui sont passé en maintenance, particulièrement en link:https://fr.wikipedia.org/wiki/Tierce_maintenance_applicative[TMA].

Du point du vue du métier, qui a généralement la main sur les questions budgétaire, cette migration n'apporte rien, il est donc logique qu'il soit réticent à dépenser de l'argent pour cela.

Il s'agit du même arbitrage que celui qui se pose pour traiter la dette technique d'un projet, sauf qu'on se place ici au niveau du SI.
Cela rend les choses plus compliqué car les intervenants sont plus nombreux.
Le critère primordial pour choisir une solution n'est pas de fâcher le moins de monde possible, mais de s'assurer que le budget soit là pour que les migrations aient bien lieu en temps et en heure.

Trois approches possibles :

- Si la roadmap du projet qui expose les services est suffisamment claire et prévisible, il est possible de préalouer le coût des migrations dans chaque projet, au même titre que les autres dépenses externes comme l'infrastructure.
- Les consommateurs demandeurs de la nouvelle version peuvent payer pour faire migrer les autres. Cela a pour effet d'augmenter le prix des demandes d'évolutions, donc de les diminuer.
- Un pot commun sous forme d'une taxe "X% du budget" appliquée à tous les consommateurs. Cela permet aux gros projets d'aider à financer les migrations des petits, pour que ceux-ci ne bloquent pas.

Une chose à surveiller dans les deux dernières approches : comme ce n'est pas le projet qui paie, il peut être tentant de gonfler la note, en profitant de la migration pour traiter d'autres sujets.
Sans aller jusqu'à demander de comptes détaillés, gardez donc l'œil ouvert.

=== Budget du projet qui expose les services

Quand un projet expose des services il le fait pour les autres, que ceux-ci contribuent à son budget.

La manière dont les consommateurs financent les évolutions influe sur le rapport du force vis-à-vis du projet :
plus l'un d'entre eux la sentiment de penser d'argent, plus il va vouloir se faire entendre lors des décisions.
Ce n'est pas une mauvaise chose en soit — il est normal que certains projets aient plus d'influence que d'autres —, mais c'est à prendre en compte.

Trois approches :

==== Faire payer les demandeurs d'une évolution

C'est l'approche la plus directe, cependant elle a deux effets secondaires :

- Désavantager les petits projets par rapport aux gros.
- Provoquer une forme d'attentisme : si un projet a besoin d'un nouveau service mais qu'il sait que le projet d'à côté l'a déjà demandé, il a tout intérêt à se taire et à laisser l'autre payer, vu qu'il y aura aussi accès.

Sur ce budget, une part est réservée pour financer la maintenance de l'existant.

=== Un pot commun

Il s'agit de mettre en commun les ressources des différents projets.
Deux axes simples pour la répartition :

- Une taxe "X% du budget";
- Au prorata de la consommation de service (au nombre d'appel).

La première alternative désavantage les gros projets s'ils utilisent peu les services.
La deuxième paraît plus juste du point de vue d'une approche service, mais elle ne reflète pas le coût réel pour le projet.

=== Composer les deux ?

Il est également possible de composer les deux approches : faire payer les demandeurs pour les évolutions et un pot commun pour la maintenance.

C'est une approche tentante car elle semble plus juste, cependant elle demande de savoir dans quelle case mettre chaque tâche.
Elle peut être intéressante sur des très gros projets en V, où les aspects budgétaires soient suivis de prêts et où la maintenance fait l'objet de chantiers spécifiques.
Cependant dans des projets plus petits et agiles qui ont appris à refactorer en permanence, mieux vaut une approche plus basique qui évitera de bureaucratiser le projet.
