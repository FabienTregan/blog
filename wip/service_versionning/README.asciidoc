= Gérer les évolutions des services dans votre SI
:toc:

Sous-titre "Versionner les services dans votre SI ça n'est pas passer de `/v1/` à `/v2/` "

== On parle de quoi

L'essentiel des discussions sur les services porte sur les questions de technique et de design.
Sur ces deux aspects on commence maintenant à disposer de pratiques bien établies et qui donnent de bons résultats.

Malheureusement dans mon expérience, dans les grandes entreprises, la difficulté la plus grave qu'on rencontre avec les services n'est pas une de celle là : il s'agit des problématiques de versionnement.

Poser le problème est très simple :

- pouvoir introduire de nouvelles versions de services pour répondre aux nouvelles demandes;
- pouvoir décomissionner les anciennes versions pour limiter le travail de maintenance et garder un SI évolutif.

Ce problème existe depuis les débuts de la SOA, mais chaque avancée dans l'organisation des projets (cycles plus courts, agile et maintenant micro-service) le rend plus critique, et aucune solution miracle n'a encore été inventée pour rendre les choses plus faciles.

Très peu de grandes organisations s'en sortent bien, car cette question mélange tous les sujets qui fâchent : gouvernance, planning et budget.

== La spécificité des services à l'intérieur d'un SI

Un service est à l'intérieur d'un SI quand il est exposé et consommé par des applications du SI.

Quand un service est exposé ou provient de l'extérieur, il fait l'objet d'une contractualisation. Sans obligatoirement aller jusqu'à un engagement de service détaillé, les engagements sont formalisés et les décisions sont prises.

En interne, la contractualisation est beaucoup plus faible voire inexistante : on se met d'accord informellement, les engagement sont moraux, et au pire on négociera une extension de budget et de calendrier.

L'avantage est qu'on est libre de décider ce qu'on veut et donc de choisir les solutions les plus adaptées, l'inconvénient est que si c'est mal fait le chaos règne.
Une des missions d'un DSI est de s'assurer la bonne marche du SI, faire en sorte que les services évoluent correctement en est un aspect essentiel.

Le cas des services avec des partenaires est un peu particulier : il est souvent "pire" que celui des services internes.
En effet pour les services internes, en escaladant suffisamment haut dans la hiérarchie, il est généralement possible d'arbitrer toutes les questions.
Par contre, entre partenaires, la situation est souvent beaucoup plus floue : officiellement on a un contrat mais dans la réalité tout est négociable et tout peut être remis en question.

Il est intéressant de noter que les géants du web communiquent peu sur ce sujet : ils peuvent être très bavard sur les outils ou les organisations projets, mais le sont beaucoup moins sur les questions d'organisation globale.

== Principes

Dans le domaine de la gouvernance de service, il n'y a pas de link:http://worrydream.com/refs/Brooks-NoSilverBullet.pdf[solution magique] qui s'applique dans tous les cas.
La meilleure solution sera celle qui est adaptée à votre contexte, et particulièrement celle que vous serez capable de mettre en œuvre.
Mais le plus est qu'il vaut mieux vaut choisir une stratégie, même si elle n'est pas la meilleure, plutôt que de ne pas avoir de stratégie et laisser régner le flou.

Une fois qu'une stratégie est choisie, l'étape suivante est de décider comment seront prises les différentes décisions.
L'idéal est qu'elles le soient le plus localement possible, c'est à dire au niveau des projets, sous réserve que l'intérêt global du SI soit respecté.

=== Deux forces opposées, et un projet au milieu

La difficulté de la gestion de version vient du fait qu'elle est à la confluence de deux forces opposées :

- les consommateurs qui ont besoins de nouvelles fonctionnalités les veulent le plus vite possible ;
- les consommateurs qui n'en ont pas besoin ne veulent pas bouger.

Les projets qui exposent les services sont pris entre ces deux feux.
Ce qu'il faut éviter à tout prix c'est que l'arbitrage entre les deux soit déléguée directement au projet.
Il s'agit du même mode de fonctionnement qu'un responsable technique à qui on demande de prioriser les demandes de deux responsables métier : cela n'aboutit à rien de bon tout en créant de la frustration.

== Exposer le minimum au minimum de clients

L'exposition de service est régie par un principe simple : exposer un service c'est créer un contrat qu'on s'engage à respecter à vis à vis des consommateurs de service, c'est donc créer l'adhérence dans le SI.

L'un des objectifs de l'approche services étant de minimiser l'adhérence entre les applications pour permettre au système d'évoluer le plus facilement possible, la conséquence est simple : il vaut mieux exposer le minimum de choses.

Pour cela plusieurs solutions :

=== N'exposez que ce dont vous avez besoin

Même si avec les outils récents il est facile d'exposer l'intégralité de vos données en REST il ne faut surtout pas le faire. D'une part vous créez une adhérence inutile, d'autre part l'API que vous créerez sera calquée sur la représentation interne de vos données et ne sera probablement pas adaptée à vos consommateurs.

=== Limitez les consommateurs tant qu'une API n'est pas sèche

Lorsque vous sortez un nouveau service il y a de grandes chances que vous ne tombiez pas juste du premier coup. Tant que vous n'êtes pas confiant dans la maturité d'une API il vaut mieux donc limiter les consommateurs.

=== Royaume / émissaire

Segmentez vos services entre ceux qui ont vocation à être utilisé par l'ensemble des applications et ceux qui ne sont utilisé que par les applications "proches". Cela permet de cranter les choses en terme d'exposition ou de rythme de migrations.

image::zones.png[title="Les zones de services"]

=== Nombre de versions à maintenir

Le choix du nombre de versions à maintenir est un arbitrage entre le producteur de services et les consommateurs :

- plus le nombre de version est faible, moins le consommateur a besoin de faire de la maintenance ;
- plus le nombre de version est élevé, plus les consommateurs ont de souplesse dans leurs migrations.

Le modèle le plus observé est d'avoir deux versions en parallèle en régime de croisière, et ponctuellement trois lors d'une bascule.
Avec deux versions, le travail de maintenance est raisonnable pour le fournisseur de service, et de laisser passer du temps entre la publication d'une nouvelle version et le décommissionnement de la version N-2 permet aux consommateurs qui le souhaitent de sauter une version sur deux.

image::versions.png[title="Un exemple de gestion de version"]

Une contrainte forte qui peut limiter le nombre de version est la capacité à conserver la compatibilité lors d'une mise à jour importante du modèle de donnée.
Une restructuration peut par exemple nécessiter de supprimer certaines opérations existantes : qu'elles soient devenues trop couteuses  en calcul, trop lentes, ou tout simplement impossibles (par exemple si une clé de partitionnement est désormais obligatoire).
Ces cas là sont à anticiper le plus possible, pour pouvoir s'organiser avec les consommateurs de donnée.

=== Quand et quoi communiquer

Le cas idéal est toujours celui où les contrats d'interface sont définis en commun entre producteur et consommateurs.
Dans cette situation, la communication est permanente et les problèmes sont identifiés au plus tôt.

Dans tous les cas, il faut communique officiellement dès qu'une interface a été définie, avant même que le code soit déployé ou même rédigé.
Pour être utilisable par les consommateurs, il ne faut pas vous limiter à un descriptif où à un contrat d'interface mais vous devez fournir :

- un contrat d'interface formalisé, peu importe le format tant qu'il est utilisable par vos utilisateurs (swagger, WSDL, RAML…);
- un document expliquant le service : si le contrat d'interface peut être suffisant pour bidouiller un appel par essai et erreur, se servir correctement d'un service nécessite de comprendre sa logique, et pour cela rien ne remplace du texte et des schémas ;
- des données d'exemples d'entrée et de sortie ;
- des mocks permettant de simuler des appels.

Si un seul de ces éléments manque, vous allez perdre du temps aux consommateurs et à vous-même : cela revient à avoir du code sans test et/ou sans documentation.

=== Modifications rétro-compatibilité dans les évolutions mineures

Si vous utilisez une gestion de version link:http://semver.org/lang/fr/[sémantique] avec des versions majeures et mineures, il est possible de pousser des évolutions dans les versions mineures, sous condition qu'elles soient rétro-compatibles.

Nous vous encourageons à suivre cette approche car elle permet d'ajouter de la flexibilité à vos services.

Même si les changements sont — en principe — transparents, attention à tout de même bien communiquer avec les consommateurs, notament pour savoir quand telle version est déployée dans tel environnement. Cela vous évitera de perdre du temps.

Cette approche doit toutefois être appliquée avec discernement :
si les évolutions majeures sont trop compliquées à mettre en œuvre, la risque est de vouloir faire passer le maximum de changement dans des versions mineures, en tordant les contrats de service.
Cela se remarque facilement à la lecture de la documentation où l'on se retrouve avec des choses comme "le paramètre `montant` représente la somme de l'opération, sauf si la valeur est -1 dans ce cas cela signifie qu'il faut annuler l'opération précédente".

Le fait qu'on soit tenté d'aller dans cette direction est une indication claire qu'il faut travailler pour fluidifier les montées de versions majeures, voire qu'il faut en faire plus souvent.

=== Compatibilité gérée par l'API Management ou l'ESB

Une des solutions mise en avant par les vendeurs d'ESB et d'API management consiste à gérer la rétro-compatiblité dans leur outil plutôt que dans du code applicatif.
En effet ces outils proposent souvent des fonctionnalités spécifiques permettant de câbler des appels à l'aide d'un outil graphique ou d'un DSL.

On ne va traiter ce sujet en détail ici car il nécessiterait un article à lui tout seul.

Pour résumer notre approche : cela peut être pertinent mais uniquement à petite dose et quand le code de compatibilité est simple et pas trop métier.
Faite particulièrement attention quand ce travail est à la charge d'une équipe transverse : rappelez-vous que cette équipe connaît moins bien le métier, et que vous ne maîtrisez pas son planning.

== À quel rythme ?

Une fois qu'on sait comment faire, la prochaine étape est le "quand ?".

Tout d'abord il n'y a pas de solution miracle valable dans tous les cas.
En fonction de votre organisation, il est même possible qu'il n'y ait pas de solution unique qui convienne pour vous.
D'une part la solution la plus adaptée dépend d'un projet à l'autre, et varie dans la vie des projets, d'autre part il s'agit d'un choix qui n'a pas d'impact global au niveau du SI.
Il est donc possible de déléguer cette décision au niveau du projet, c'est à dire par le groupe formé par le projet qui expose les services et les consommateurs de ses différents services.

Il y a deux stratégies possibles :

=== Rythme cadencé

Il s'agit de prévoir les évolution de services à un rythme régulier "tous les X", en général tous les X mois.
Ce rythme ne correspond pas au rythme de release du projet : il peut livrer régulièrement sans modifier les services qu'il expose.
Par ailleurs il s'agit de cadencer la possibilité de faire évoluer les services : ce n'est pas parce qu'on a réservé un créneau qu'il faut forcément s'en servir. S'il n'y a rien à changer alors on le passe.

Cette possibilité est plus contraignante pour le projet qui expose, mais la prévisibilité permet aux consommateurs de s'organiser, voire de provisionner les budget de migrations.

Elle est par exemple la plus indiquée dans un contexte non agile où on préfère la prévisibilité à la vitesse.

=== Rythme opportuniste

Dans cette stratégie on fait évoluer le service quand on en a besoin.

Il ne s'agit pas de le faire à l'arrache : il faut bien entendu anticiper les modifications, et laisser aux consommateurs le temps de migrer : on ne dégrade pas la qualité sous prétexte qu'on est plus adaptable.

Mais plutôt que de prévoir des créneaux à l'avance, on préfère le faire en cas de besoin.

Cette approche convient le mieux en début et en fin de projet :

- au début les changements sont les fréquents, pouvoir agir à la demande est plus pratique ;
- en fin de projet lorsque les choses se sont stabilisées, les modifications deviennent occasionnels.

=== Majeur et mineur

Il est possible de mixer les deux approches :
- une approche cadencée pour les versions majeures;
- une approche opportuniste pour les versions mineures.

Ainsi on anticipe les changements bloquants, et on peut fournir au plus tôt les changements transparents.

=== Royaume / émissaire

Le cas du royaume émissaire va complexifier le tableau : les services qui restent à l'intérieur d'une même zone du SI vont avoir tendance à bouger plus rapidement que les services entre zones.
On peut donc avoir une politique différente pour les deux types de services.

Les projets à l'intérieur d'une même zone ayant naturellement tendance à bouger ensemble, suivant que les évolutions du métier porte sur l'un puis l'autre sujet, ils vont probablement adopter un rythme similaire.

== Si un projet client ne peut pas évoluer

Il s'agit d'une question qui ne se poserait pas dans un monde parfait, mais qui en pratique arrive régulièrement : que faire si un projet ne peut pas évoluer et que la solution la plus évidente serait de conserver pour une version de vos service pour lui ?

En anticipant sur la partie suivante, nous allons parler budget.

Avant de choisir cette solution, il faut se rappeler que ce type de compatibilité a un prix.
Ce prix ne se solde pas en une fois mais il s'agit d'un surcoût qui s'ajoute à chaque évolution pour maintenir la rétro-compatibilité.
Par ailleurs ce prix va augmenter au fur et à mesure que la version gelée s'écarte de la version standard et que la rétro-compatibilité devient de plus en plus complexe.

Ce prix est de trois ordres :

- en argent pour le temps passé ;
- en complexité dans le code pour gérer la compatibilité ;
- en motivation pour les développeurs qui doivent prendre en compte cette contrainte lors de chaque évolution.

La seule solution viable, si on veut conserver une rétro-compatibilité pour un consommateur c'est ce que ce soit lui qui finance ce budget.
Cette approche a trois avantages :

- Elle est dissuasive car les projets sont incités à migre ;
- Elle est équitable car c'est le demandeur qui paie ;
- Elle va dans le bon sens car, avec le prix qui va augmenter avec le temps, il y a l'espoir qu'à un certain moment le consommateur saute le pas et se décide à migrer.

Le dernier avantage ne devrait avoir à s'appliquer car, dans un monde idéal, lorsqu'on décide de maintenir une compatibilité c'est pour un temps limité et qui devrait être fixé dès le début.
Dans les fait lorsqu'un projet décroche une telle exception il est tentant de jouer les prolongation, l'augmentation du prix est donc là pour contrebalancer cette tendance.

Ne pas faire payer le consommateur revient à donner une prime à ceux qui ne jouent pas le jeux : si vous ne migrez pas, non seulement vous n'avez plus à vous embêter, mais en plus vous ne payer rien !

=== Il ne doit en rester qu'un

Si malgré tout vous faites le choix de garder une version pour un consommateur, il est très important de tout faire pour faire migrer tous les autres.
En effet une fois que l'exception sera connue, d'autres vont être tentés de s'engouffrer dans la brèche qui vient d'être ouverte et de rester sur la même version.
Économiquement cette approche est attirante car le prix de la maintenance est alors réparti entre tous les projets, à la limite un projet qui voudrait arrêter de migrer aurait même intérêt à en convaincre d'autres pour diviser sa note.

Mais cette approche est très dangereuse : plus il y a de consommateurs bloqués sur une version, plus il y a de chances que vous ayant à maintenir cette version longtemps, voire indéfiniment.

C'est l'un où des cas où la gouvernance stratégique a sa place : car l'optimisation globale du SI s'oppose directement à des solutions opportunistes.

== Budget

Une fois toutes les bonnes résolutions prises, reste une question, probablement la plus importante : qui paie ?

Comme dans certains des autres sujets traités, il n'y a pas de réponse qui convienne dans tous les cas.
La différence ici c'est qu'il vaut peut-être mieux choisir une même approche pour tous les projets pour limiter le nombre de fois où on rouvre ce débat.
Les prises de décisions sur les questions de budgets étant extrêmement difficiles, cela permet de limiter les conflits, même si à chaque cycle budgétaire la tentation est grande de tout remettre en cause.

=== Budget des consommateurs

Quand un consommateur de service a besoin de nouvelles fonctionnalités il n'aura pas de soucis à financer la migration vers la nouvelle version d'une API qui va lui fournir ce dont il a besoin.

Les questions de budget se posent quand le consommateur est satisfait de ce qu'il a déjà et qu'il faut migrer à la version suivante.
Le problème se plus particulièrement pour les projets qui sont passé en maintenance, particulièrement en link:https://fr.wikipedia.org/wiki/Tierce_maintenance_applicative[TMA].

Du point du vue du métier, qui a généralement la main sur les questions budgétaire, cette migration n'apporte rien, il est donc logique qu'il soit réticent à dépenser de l'argent pour cela.

Il s'agit du même arbitrage que celui qui se pose pour traiter la dette technique d'un projet, sauf qu'on se place ici au niveau du SI.
Cela rend les choses plus compliqué car les intervenants sont plus nombreux.
Le critère primordial pour choisir une solution n'est pas de fâcher le moins de monde possible, mais de s'assurer que le budget soit là pour que les migrations aient bien lieu en temps et en heure.

Trois approches possibles :

- Si la roadmap du projet qui expose les services est suffisamment claire et prévisible, il est possible de préalouer le coût des migrations dans chaque projet, au même titre que les autres dépenses externes comme l'infrastructure.
- Les consommateurs demandeurs de la nouvelle version peuvent payer pour faire migrer les autres. Cela a pour effet d'augmenter le prix des demandes d'évolutions, donc de les diminuer.
- Un pot commun sous forme d'une taxe "X% du budget" appliquée à tous les consommateurs. Cela permet aux gros projets d'aider à financer les migrations des petits, pour que ceux-ci ne bloquent pas.

Une chose à surveiller dans les deux dernières approches : comme ce n'est pas le projet qui paie, il peut être tentant de gonfler la note, en profitant de la migration pour traiter d'autres sujets.
Sans aller jusqu'à demander de comptes détaillés, gardez donc l'œil ouvert.

=== Budget du projet qui expose les services

Quand un projet expose des services il le fait pour les autres, que ceux-ci contribuent à son budget.

La manière dont les consommateurs financent les évolutions influe sur le rapport du force vis-à-vis du projet :
plus l'un d'entre eux la sentiment de penser d'argent, plus il va vouloir se faire entendre lors des décisions.
Ce n'est pas une mauvaise chose en soit — il est normal que certains projets aient plus d'influence que d'autres —, mais c'est à prendre en compte.

Trois approches :

==== Faire payer les demandeurs d'une évolution

C'est l'approche la plus directe, cependant elle a deux effets secondaires :

- Désavantager les petits projets par rapport aux gros.
- Provoquer une forme d'attentisme : si un projet a besoin d'un nouveau service mais qu'il sait que le projet d'à côté l'a déjà demandé, il a tout intérêt à se taire et à laisser l'autre payer, vu qu'il y aura aussi accès.

Sur ce budget, une part est réservée pour financer la maintenance de l'existant.

=== Un pot commun

Il s'agit de mettre en commun les ressources des différents projets.
Deux axes simples pour la répartition :

- Une taxe "X% du budget";
- Au prorata de la consommation de service (au nombre d'appel).

La première alternative désavantage les gros projets s'ils utilisent peu les services.
La deuxième paraît plus juste du point de vue d'une approche service, mais elle ne reflète pas le coût réel pour le projet.

=== Composer les deux ?

Il est également possible de composer les deux approches : faire payer les demandeurs pour les évolutions et un pot commun pour la maintenance.

C'est une approche tentante car elle semble plus juste, cependant elle demande de savoir dans quelle case mettre chaque tâche.
Elle peut être intéressante sur des très gros projets en V, où les aspects budgétaires soient suivis de prêts et où la maintenance fait l'objet de chantiers spécifiques.
Cependant dans des projets plus petits et agiles qui ont appris à refactorer en permanence, mieux vaut une approche plus basique qui évitera de bureaucratiser le projet.
