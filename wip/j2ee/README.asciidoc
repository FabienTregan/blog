= Retour sur les serveurs d'application Java

Quand j'ai commencé à travailler, les serveurs d'applications Java étaient à la mode.

image::511WWNNA41L.jpg[title="Souvenirs, Souvenirs"]

Aujourd'hui ils ont quasiment disparu du paysage, et quand on prononce le mot "J2EE", c'est surtout pour évoquer des promesses déçues et des projets terminés dans la douleurs.

En y repensant, je me suis rendu compte d'une chose :
certes les spécifications et les produits avaient de nombreux problèmes,
mais de nombreuses approches qu'on critiquait alors se sont révélées les bonnes sur le long terme.

Je ne veux pas dire que _toutes_ les idées étaient bonnes : certaines étaient franchement mauvaises, et n'auraient jamais pu fonctionner même dans le meilleur de mondes.
La multiplication des nouveautés était en elle-même source de difficultés car les systèmes résultants sont très complexes, link:http://www.bbc.com/news/business-11944966[même les éditeurs le disent].

Si vous êtes un·e jeune développeur·euse, pour qui J2EE évoque une époque lointaine et mystérieuse, comme le jurassique ou le septennat de Valéry Giscard d'Estaing, cet article vous permettra de comprendre pourquoi les personnes étaient aussi enthousiastes à l'époque, et pourquoi il·elle·s sont parfois un peu dubitatifs face aux promesses de nouvelles technologies.

Si vous êtes une personnes expérimentée qui a vécu cette époque et qui utilise peut-être encore ces technologie : cela vous donnera des idées sur les nouvelles approches utilisées aujourd'hui, notamment qu'elles ne sont pas par amour de la nouveauté mais pour répondre à des besoins réels que vous aviez peut-être vous-même mais que vous avez renoncé à satisfaire.

== Note : J2EE et serveurs d'application d'entreprise

Dans l'article, je  mélange fonctionnalités J2EE et fonctionnalités fournies par la plupart des serveurs d'application d'entreprise. Je me permets de le faire pour deux raisons :

* Les différents serveurs Java d'entreprise ont rapidement fourni le même type de fonctionnalités, qu'elles soient ou pas dans la spécification ;
* Personne n'a jamais vraiment compris le périmètre de J2EE : entre ce qui était dans la spécification et qui ne fonctionnait pas, ce qui était pas dans la spécification et qui fonctionnait mais seulement de manière non portable … personne n'y retrouvait ses petits.

== Gestion de cluster et scalabilité

À l'arrivées des serveurs d'applications, le web était l'avenir, et la manière d'y aller était la scalabilité horizontale.
L'approche en vogue de remplacer les mainframe par des fermes de serveurs Unix, moins puissants mais beaucoup moins cher.

Pour limiter la complexité induite par la multiplication des machines, l'idée est de gérer un ensemble de serveurs vus comme une ressource unique et plus des machines une par une.
Toutes les fonctions de clustering était implémentées par le serveur d'application.

Pourquoi ça ne fonctionnait pas ?

* Beaucoup de fonctionnalités _cluster-aware_ fonctionnaient mal, on se contentait donc d'utiliser le minimum qui fonctionnait comme le monitoring.
* Les machines Unix de l'époque restaient coûteuses en matériel et en licenses et d'une puissance limitée. De plus ajouter de nouveaux serveurs physique n'était pas simple : il fallait trouver de la place dans des baies, tirer des câbles …. En pratique il s'agissait surtout d'être conservateur en utilisant au mieux un nombre limité de machines.

Aujourd'hui, si les mainframe sont toujours là, les serveurs Unix eux sont en train de faire leur sortie.
Les serveurs x86 qui les ont remplacés disposent d'une quantité mémoire bien supérieure pour le même prix, et l'automatisation et la virtualisation permettent plus facilement d'ajouter des serveurs.
La scalabilité n'est pas gérée au niveau des serveurs d'applications mais par l'infrastructure et les outils : proxys, réseau …

== La mutualisation des serveurs

Comme on l'a déjà dit, les machines de l'époque coûtaient cher.
Pour mutualiser la consommation de mémoire  il était possible de déployer plusieurs application dans un serveur d'application.
Cette approche était aussi beaucoup utilisée pour limiter les coûts de licenses.

Pourquoi ça ne fonctionnait pas ?

* L'isolation de composants n'était pas à la hauteur : une application qui consommait trop de resources mettait en danger les autres, et certaines modifications nécessitaient des redémarrage du serveur, même si elles n'étaient utiles que pour seule application.

Aujourd'hui : on mutualise toujours mais l'augmentation de la mémoire des serveurs permet de le faire plus "bas" qu'au niveau du serveur : après la phase "une VM pour chaque application", les conteneurs ont la même approche, et les problèmes d'isolations sont de retour.

== Bascule à chaud

Pour éviter les interruptions de services, les serveurs devraient pouvoir faire des bascules à chaud sur un nouvelle version d'une application.
Sur le papier, l'idée était prometeuse : le serveur routait les nouvelles requêtes sur la nouvelle version, en laissant les  requêtes en cours d'exécution se terminer, puis décommissionnait l'ancienne version quand plus aucune requête ne l'utilisait.

Ce déploiement et cette bascule étaient même _cluster-aware_ : les artefacts étaient déployés automatiquement sur tous les nœuds du groupe de serveurs.

Pourquoi ça ne fonctionnait pas ?

* Cela ne correspondait pas aux pratiques ops de l'époque.
* Des problèmes de fuites mémoire, certaines dues à des problèmes d'implémentation, d'autres structurelles, rendaient l'utilisation de la fonctionnalité risquée. Mieux valait une interruption de service planifiée qu'un crash inattendu et non prévu.

Aujourd'hui : les pratiques ops ont beaucoup évolué mais certains problèmes de fuite mémoire sont toujours là.
Au final la bascule se fait plutôt par des proxys réseau qu'au niveau d'un serveur.

== JNDI

JNDI permettait de spécifier des paramètres à passer aux applications depuis le serveur. Cela aurait du permettre de redéployer le même artefact de la recette à la production sans avoir à lui adjoindre de fichiers de configurations propre à chaque étape.

Pourquoi ça ne fonctionnait pas ?

* La plupart des frameworks Java ne le supportaient pas et ne savaient que lire des fichiers de configurations.
* L'outillage et les pratiques n'étaient pas adaptées de sorte qu'on se retrouvait souvent à modifier les variables manuellement sur les serveur, sans audit et gestion de version.

Aujourd'hui : c'est la même approche choisie par Docker via les variables d’environnement, et les outils sont en train de se moderniser pour s'y adapter.

== Gestion de session _cluster-aware_

Les serveurs fournissaient une gestion de session utilisation, l'équivalent d'un outil NoSQL intégré.

Pourquoi ça ne fonctionnait pas ?

* Les implémentation fournies nativement pas les serveurs d'applications n'était pas à la hauteur en terme de performance et de fiabilité, et les implémentations externes fiables ont mis du temps à arriver.
* Les patterns n'étaient pas encore matures et les développeur·euse·s avaient tendance à vouloir stocker beaucoup trop de choses en session car c'était "magique", ce qui écroulait les performances.

Aujourd'hui : on a appris à stocker le minimum dans une session voire à s'en passer, et des solutions NoSQL sont matures et permettent de répondre aux besoins

== EJBs

Les EJBs sont un moyen de packager des groupes de fonctionnalités dans un artefact en exposant une façade normée sous forme de services.
L'idée était de permettre de développer des applications complexes en composants des briques élémentaires bien séparées avec des appels transactionnels entre elles tout en permettant de link:https://blog.octo.com/decouplage-decouplage-decouplage/[masquer la localisation].
Lorsque les EJBs étaient déployés ensemble les appels se faisaient localement, ce qui permettait d'économiser la latence réseau en conservant l'isolation.

Pourquoi ça ne fonctionnait pas ?

* Un mauvais découpage métier faisait qu'on aboutissait souvent à un plat de spaghetti.
* Les découplages de service se faisaient sans découplage de persistance, ce qui limitait l'indépendance des différents composants.

Aujourd'hui : les microservices vont dans la même direction en s'appuyant sur d'autres protocoles, mais les avancées dans les pratiques pourraient faire en sorte que les résultats soient meilleurs.

== JAAS

JAAS est la partie sécurité de J2EE, elle permet de faire du contrôle d'accès au niveau des services, par annotations ou à l'aide de XML.
Cela permet de gérer la sécurité de manière déclarative.

Pourquoi ça ne fonctionnait pas ?

* La spécification JAAS n'était pas assez complète, ce qui nécessitait de faire du spécifique pour chaque éditeur.
* L'API _Security Provider_ à utiliser pour des implémentation spécifiques était très mal documentée et mal supportée.
* Le contrôle d'accès n'était pas au niveau de la donnée, ce qui obligeait à implémenter une deuxième couche de sécurité au niveau du code.

Aujourd'hui : JAAS est remplacé par des frameworks plus léger comme Spring Security, qui peuvent s'appuyer sur JAAS suivant les cas mais qui en masquent les limites.

== Redéploiement à chaud

La JVM était lente à démarrer, les applications lentes à déployer, et J2EE rendait difficile d'écrire du code facile à tester hors du serveur.
Pour accélérer le cycle le développement, l'idée était de permettre un redéploiement à chaud de l'application sans avoir à tout recharger pour que le·a développeur·se ne soit pas interrompu·e dans son travail.

Pourquoi ça ne fonctionnait pas ?

* Pendant longtemps la fonctionnalité n'a pas été stable, ce qui faisait perdre du temps : "est ce que c'est un bug dans mon code ou est ce que c'est le rechargement qui a cassé un truc ?".
* Seuls certains types de modifications étaient valides (typiquement celles qui étaient limitées à l'intérieur de classes), et celles qui ne l'étaient pas n'étaient pas documentées et ne généraient pas d'erreur.

Au final la meilleure approche était de s'en passer, quitte à ajouter des couches d'indirections pour isoler artificiellement le code.

Aujourd'hui la JVM et les serveurs d'applications ont été optimisés et les processeurs vont beaucoup plus vite (sur un MacBook Pro dernière génération, démarrer un serveur IBM Websphere ne prend plus qu'une vingtaine de minutes…).
JEE de son côté a pris en compte ces problèmes et permet aujourd'hui de tester hors serveur.

Les alternatives à JEE tels que DropWizard ou Spring sont d'ailleurs encore plus rapides.

Les limites ayant causé la nécessité d'avoir cette fonctionnalité ayant disparu, elle est désormais inutile.

== Pour conclure

Cette revue permet de dégager deux choses :

D'abord beaucoup d'idées ont échoué pour cause de maturité autant voir plus que pour des raisons techniques.

Ensuite Les serveurs d'applications essayaient de résoudre beaucoup de problèmes tous seuls.
Aujourd'hui les solutions sont réparties à différents niveau de la _stack_ : de l'OS à la configuration réseau.
Cela permet de diminuer la complexité de ce qui est demandé aux stack applicatives et donc de faciliter l'adoption de nouvelles technologies.
Cela veut aussi dire que les serveurs d'applications à l'ancienne sont désormais un poids mort dans un SI.

Espérons qu'ils pourront bientôt profiter de leur retraite bien méritée, et qu'ils pourront y attendre sereinement que les mainframe les y rejoignent.
