= Middleware d'entreprises : nous ne sommes plus en l'an 2000
Julien Kirch
v1.0, 2015-09-01

== De quoi on parle ?

Quand j'ai commencé à travailler dans les années 2000, [line-through]#les dinosaures dominaient le monde# les projets étaient en train de changer.
Grâce aux tests automatisés, à l'extreme programming et aux nouveaux outils qui arrivaient comme les serveurs d'applications et Subversion, on apprenait à développer mieux et plus vite.

L'un des points qui posait problème était les middleware d'entreprises : ils nous semblaient lourds et inadaptés à nos nouvelles pratiques, et ont commencé à devenir des goulets d’étranglement.

Presque 15 ans plus tard, avec les pratiques agiles et le Devops, les pratiques ont bien changé.
Malheureusement ce n'est pas le cas pour un certains nombres d'outils : ils ont enrichis leurs fonctionnalité, mais ne se sont pas transformés.

Dans différents domaines, ces outils peuvent désormais être un vrai frein pour votre capacité à délivrer.
Il faut garder en tête qu'un environnement technique est toujours nivelé par le bas : le plus mauvais outil dicte ses contraintes à toute la chaîne.

Prendre conscience de ces limitations peut vous aider dans deux situations :

- Si vous devez choisir un nouvel outil, cela vous permettra d'être certain que vos critères d'évaluation couvrent bien ces caractéristiques. Chez Octo, lors des missions de sélections d'outils, cela fait longtemps que ces prérequis font partie des éléments critiques.
- Si vous avez déjà ces outils, cela vous permettra de vous rappeller les limites qu'il vous impose, et vous fera peut-être réaliser qu'il est temps d'en changer.

=== C'est quoi un middleware d'entreprise ?

image::easter.jpg[title="Des middleware d'entreprise dans leur habitat naturel, photo par Arian Zwegers en CC"]

Il s'agit d'un groupe aux limites assez floues mais qu'on peut délimiter par un certains nombres de caractéristiques :

- il s'agit d'outils transverses ;
- ils peuvent être structurants pour le SI suivant l'usage qui en est fait ;
- leur choix n'est pas laissé à la main de chaque projet mais est effectué de manière transverse, souvent par une cellule d'architecture et/ou l'équipe en charge de l'exploitation ;
- ils sont choisis pour durer, et donc sont souvent évalués pour leur capacité à répondre à des besoins qu'on a identifié, mais qui après coup ne se réalisent pas toujours.

== Logiciels propriétaires

Les middleware d'entreprises est un des derniers bastions des logiciels propriétaires.
Le problème n'est pas le fait d'utiliser des logiciels propriétaires, mais les conséquences des pratiques de certains éditeurs sur l'utilisation des logiciels.

=== La gestion des licenses

Tout d'abord il y a la gestion des licences : si nous comprenons que l'éditeur veuille s'assurer que ses logiciels soient dûment utilisés, mais il faut que cela soit fait proprement.

L'idéal est un fichier de license fixe à copier sur les serveurs, que cela soit un fichier unique ou un fichier par environement : avec des outils de déploiement, il n'y a pas de dégradation par rapport à un outil ouvert.

La capacité des outils de middleware à être élastique est maintenant souvent mise en avant (et on en reparlera plus bas). Si ce sujet est important pour vous, vérifiez que d'ajouter des nœuds dans un cluster ne nécéssitera pas de changer en même temps le fichier de license dans chacun des serveurs, y compris les serveurs existans.

La pire situation est un "serveur de license" que link:https://en.wikipedia.org/wiki/Phoning_home[l'outil appele pour valider sa licence].

Deux cas ce posent.

Si le serveur de license est installé localement, non seulement cela ajoute de la complexité dans le SI sans bénéfice pour vous, mais la mise en œeuvre pêche souvent à deux endroits :
- Ils sont souvent moins bien outillés et documentés que les serveurs opérationnels, les installer et les opérer est souvent plus difficile.
- Ils sont rarement prévus pour fonctionner en haute disponibilité et il s'agit donc de link:https://fr.wikipedia.org/wiki/Point_individuel_de_défaillance[SPOFs]. Quand ils sont seulement utilisés dans un but de collecte d'information cela est juste pas très professionel. Mais quand les serveurs opérationnels doivent appeller le serveur de license régulièrement ou lors de chaque démarrage pour pouvoir fonctionner, un serveur de license non accessible c'est un morceau ou tout votre SI qui s'arrête.

Si le serveur de license est hébergé par l'éditeur sur Internet :
- Le même risque opérationnel se pose en cas de serveur indisponible : êtes vous prêt à vous passer de votre ESB à usage strictement interne si votre connexion internet tombe ?
- Un risque de sécurité  : sans tomber dans la paranoïa, un serveur qui fait un appel sortant que vous ne maitrîsez pas est toujours dangereux. À vous d'en évaluer les conséquences.

=== Le prix

Le prix est un critère de choix pour sélectionner la solution, mais il 

Problèmes quand la license / le support / le prix font que tu es obligé de choisir une solution sous-optimale.

Model de pricing et Elasticité : s'il faut renégocier alors que tu as un pic de charge, ils vont se faire plaisir.

Sois pas d'environement de test, ou d'avoir deux solutions (gold / silver).

== Architecture

Souvent HA sauf la console d'admin
Clustering dynamique

=== Physique ou virtuel ?

Deployable en VM sauf bonne raison
Appliance logique : tout est industrialisable à partie de l'image de base cloud-init
Applicance Difficile à opérer, faille de sécu, difficile à instancier si physique
Futur docker ?

Logiciel > Docker > VM > Machine Physique

== Déploiement et configuration

Pas besoin d'outil extérieur pour builder

Critère facile : si l'outil vient avec ses ensembles de fichier Chef / Puppet / Ansible, mais jetez quand même un œil (parfois configuration de base qu'on modifie ensuite avec l'IDE...).

Packaging : suivre les standard LSB

- Fichiers de configuration templatisables dans une syntaxe lisible
  - Pas dans un format binaire ou difficile à modifier (type objet java sérailisé)
- les variables à un seul endroit
- Diffables

Passage d'un environement à l'autre: obligé de refaire les mêmes manipulations avec risque d'erreur

== Développement en équipe et gestion de version

Problème notament avec les outils qui viennent avec un IDEs

Usage limités à une seule personne à la fois : convennait très bien quand on a une équipe dédiée à l'outil et qu'on a des cycles de livraisons lents.
- impossible de faire des merges en utilisant un gestionnaire de version

== Test

Facilité de tester de manière automatisé.

== Exploitabilité

=== Monitoring

Pas de polling pour avoir l'info
Une API
Un format standard (JMX, SNMP)

=== Log

- Connecteur standard : syslog au minimum
- Faciles à parser et univoques, JSON monoligne
- Horodatés
- Flushés
