= Middleware d'entreprises : nous ne sommes plus en l'an 2000
Julien Kirch
v1.0, 2015-09-01

== De quoi s'agit-il ?

Quand j'ai commencé à travailler dans les années 2000, [line-through]#les dinosaures dominaient le monde# les projets étaient en train de changer.
Grâce aux tests automatisés, à l'extreme programming et aux nouveaux outils qui arrivaient comme les serveurs d'applications et Subversion, on apprenait à développer mieux et plus vite.

L'un des points qui posait problème était les middleware d'entreprises : ils nous semblaient lourds et inadaptés à nos nouvelles pratiques, et ont commencé à devenir des goulets d’étranglement.

Presque 15 ans plus tard, avec les pratiques agiles et le Devops, les pratiques ont bien changé.
Malheureusement ce n'est pas le cas pour un certains nombres d'outils : ils ont enrichis leurs fonctionnalité, mais ne se sont pas transformés.

Dans différents domaines, ces outils peuvent désormais être un vrai frein pour votre capacité à délivrer.
Il faut garder en tête qu'un environnement technique est toujours nivelé par le bas : le plus mauvais outil dicte ses contraintes à toute la chaîne.

S'il est parfois possible de contourner ces limitations, il s'agit généralement de rustines fragiles. Et rappelez-vous que les outils sont sensé vous aider et pas se mettre sur votre route pour vous empêcher de travailler.

Prendre conscience de ces limitations peut vous aider dans deux situations :

- Si vous devez choisir un nouvel outil, cela vous permettra d'être certain que vos critères d'évaluation couvrent bien ces caractéristiques. Chez Octo, lors des missions de sélections d'outils, cela fait longtemps que ces prérequis font partie des éléments critiques.
- Si vous avez déjà ces outils, cela vous permettra de vous rappeler les limites qu'il vous impose, et vous fera peut-être réaliser qu'il est temps d'en changer.

=== C'est quoi un middleware d'entreprise ?

image::easter.jpg[title="Des middleware d'entreprise dans leur habitat naturel, photo par Arian Zwegers en CC"]

Il s'agit d'un groupe aux limites assez floues mais qu'on peut délimiter par un certains nombres de caractéristiques :

- il s'agit d'outils transverses ;
- ils peuvent être structurants pour le SI suivant l'usage qui en est fait ;
- leur choix n'est pas laissé à la main de chaque projet mais est effectué de manière transverse, souvent par une cellule d'architecture et/ou l'équipe en charge de l'exploitation ;
- ils sont choisis pour durer, et donc sont souvent évalués pour leur capacité à répondre à des besoins qu'on a identifié, mais qui après coup ne se réalisent pas toujours.

Les exemples les plus courants sont les link:https://fr.wikipedia.org/wiki/Message-oriented_middleware[bus de messages], les link:https://en.wikipedia.org/wiki/Enterprise_service_bus[bus d'entreprises], les link:https://fr.wikipedia.org/wiki/Extract-transform-load[ETL], les outils d'API management et les appliances de sécurité.
Même s'il ne s'agit pas de middlewares, de nombreuses briques logicielles suivent les mêmes règles, par exemples les link:https://fr.wikipedia.org/wiki/Java_EE[serveurs d'applications] ou les technologies de virtualisation.

== Logiciels propriétaires

Les middleware d'entreprises est un des derniers bastions des logiciels propriétaires.
Le problème n'est pas le fait d'utiliser des logiciels propriétaires, mais les conséquences des pratiques de certains éditeurs sur l'utilisation des logiciels.

=== La gestion des licences

Tout d'abord il y a la gestion des licences : si nous comprenons que l'éditeur veuille s'assurer que ses logiciels soient dûment utilisés, mais il faut que cela soit fait proprement.

L'idéal est un fichier de licence fixe à copier sur les serveurs, que cela soit un fichier unique ou un fichier par environnement : avec des outils de déploiement, il n'y a pas de dégradation par rapport à un outil ouvert.

La capacité des outils de middleware à être élastique est maintenant souvent mise en avant (et on en reparlera plus bas). Si ce sujet est important pour vous, vérifiez que d'ajouter des nœuds dans un cluster ne nécessitera pas de changer en même temps le fichier de licence dans chacun des serveurs, y compris les serveurs existants.

Depuis que les link:https://fr.wikipedia.org/wiki/Dongle[dongle matériels] ont quasiment disparus, la pire situation est un "serveur de licence" que link:https://en.wikipedia.org/wiki/Phoning_home[l'outil appelle pour valider sa licence].

Deux cas se posent.

==== Serveur de licence local

Quand vous devez installer vous-même un serveur de license.

- Cela ajoute de la complexité dans le SI sans bénéfice pour vous.
- Ils sont souvent moins bien outillés et documentés que les serveurs opérationnels, les installer et les opérer est souvent plus difficile.
- Ils sont rarement prévus pour fonctionner en haute disponibilité et il s'agit donc de link:https://fr.wikipedia.org/wiki/Point_individuel_de_défaillance[SPOFs]. Quand ils sont seulement utilisés dans un but de collecte d'information cela est juste pas très professionnel. Mais quand les serveurs opérationnels doivent appeler le serveur de licence régulièrement ou lors de chaque démarrage pour pouvoir fonctionner, un serveur de licence non accessible c'est un morceau ou tout votre SI qui s'arrête.

==== Serveur hébergé par l'éditeur

Quand le serveur est hébergé par l'éditeur.

- Le même risque opérationnel se pose en cas de serveur indisponible : êtes vous prêt à vous passer de votre ESB à usage strictement interne si votre connexion internet tombe ?
- Un risque de sécurité  : sans tomber dans la paranoïa, un serveur qui fait un appel sortant que vous ne maitrisez pas est toujours dangereux. À vous d'en évaluer les conséquences.

=== Le prix

Le prix est d'abord un critère de choix pour sélectionner la solution, mais il peut aussi avoir des conséquences sur son utilisation.

==== Mutualiser les instances

Si le prix est payé par serveur, pour économiser vous aurez intérêt à diminuer le nombre d'instances.
La conséquence est souvent une tentation de mutualiser les serveurs au delà du raisonnable.
Le cas qu'on rencontre couramment est celui des serveurs d'applications Java. Les limitations du modèle J2E font que, malgré ce qu'en disent certains vendeurs, utiliser un seul serveur pour plusieurs applications pose un tas de problèmes : ressources non isolées, fuites mémoires…
Les utilisateurs qui ont le choix utilisent systématiquement un serveur par applications, les seuls qui mutualisent leurs serveurs sont ceux qui le font pour limiter leur coûts de license, et la contrepartie est de rendre leur système moins fiable.

==== Mutualiser les environements

On peut aussi être amené à mutualiser les environnements : en fonction de la pression sur les prix, on mutualisera les serveurs de plusieurs environnements au lieu de les isoler.

Les problèmes que cela pose dépendent de la manière dont la mutualisation est faite :

- Les environnements de pré-production et de production sont souvent les seuls à fonctionner en cluster, augmentant d'autant les prix. Quand ils s'executent sur les mêmes serveurs, les tests de performances effectués en pré-production risquent de faire tomber la production.
- Si les environnements de tests sont mutualisés et celui de production dédié, le risque est celui d'avoir des configuration différente dans les deux cas et donc d'avoir des régressions.

==== Deux solutions

La dernière possibilité est d'être obligé d'utiliser deux systèmes différents : un système pour les besoins "critiques", et un autre système pour les besoins "non critiques".
Cette approche repose sur l'idée est que pour les besoins les plus importants, seule peut convenir une solution vendue par un grand éditeur.
Il s'agit d'une survivance des années 2000 où les solutions open-souces ou vendues par des petits éditeurs étaient souvent moins avancées, et leur support réputé moins fiable.
Étant donné le prix de la solution critique il n'est malheuresement pas possible de l'utiliser partout.
Il est donc nécessaire de choisir une deuxième solution pour les autres besoins, ce qui complexifie votre système et augmente son coût.

== Architecture

Après les question de licenses l'architecture.

=== Haute disponibilité

La haute disponibilité fait désormais partie des fonctionalités standard exigées des produits, mais une subtilité est tout de même à vérifier :
dans le cas où en plus des serveurs d'execution, existe un serveur d'administration, celui-ci peut ne pas être en haute disponibilité.
Même si la criticité est moindre (quand le serveur d'administration est indisponible, le système devrait continuer à fonctionner le temps qu'il soit réparé), il s'agit tout de même d'un point de fragilité.

=== Élasticité

L'autre élément à eximaniner est l'élasticité car, si beaucoup de produits revendiquent cette propriété, certains prennent des libertés avec son usage courant.
Vérifiez l'impact de l'ajout ou la suppression d'un nœud : selon les outils cela peut aller de "aucun" à "il faut redémarrer tous les serveurs" en passant par "dégradation pendant le rééquilibrage de données".

=== Physique ou virtuel ?

La virtualisation est désormais la règle.
Un logiciel qui nécessite d'être hébergé sur du bare metal aura donc besoin d'une bonne raison pour cela.

En dehors de quelques systèmes de niche (sécurité, très haute performance), les appliances physiques sont désormais une espèce disparue.
Leur remplacement par des appliances virtuelles supprimer la contrainte physique, mais pas les autres :

- une brique que vous ne pourrez pas monitorer de la même manière que les autres ;
- un risque car il faut faire confiance à l'éditeur pour maintenir le système à jour et sécurisé.

Il s'agit donc toujourd d'un pis-aller.
En cas d'appliance, vérifiez que l'image est compatible avec link:https://help.ubuntu.com/community/CloudInit[cloud-init], ce qui vous permettra de l'ajouter facilement dans vos outils de provisionning.
L'avenir dans ce domaine est probablement d'aller vers du Docker : l'éditeur aura toujours la main sur l'installation, mais cela permettra de jeter un œil dans la boite noire tout en économisant des resourses.

== Déploiement et configuration

Pas besoin d'outil extérieur pour builder

Critère facile : si l'outil vient avec ses ensembles de fichier Chef / Puppet / Ansible, mais jetez quand même un œil (parfois configuration de base qu'on modifie ensuite avec l'IDE...).

Packaging : suivre les standard LSB

- Fichiers de configuration templatisables dans une syntaxe lisible
  - Pas dans un format binaire ou difficile à modifier (type objet java sérailisé)
- les variables à un seul endroit
- Diffables

Passage d'un environement à l'autre: obligé de refaire les mêmes manipulations avec risque d'erreur

== Développement en équipe et gestion de version

Problème notament avec les outils qui viennent avec un IDEs

Usage limités à une seule personne à la fois : convennait très bien quand on a une équipe dédiée à l'outil et qu'on a des cycles de livraisons lents.
- impossible de faire des merges en utilisant un gestionnaire de version

== Test

Facilité de tester de manière automatisé.

== Exploitabilité

=== Monitoring

Pas de polling pour avoir l'info
Une API
Un format standard (JMX, SNMP)

=== Log

- Connecteur standard : syslog au minimum
- Faciles à parser et univoques, JSON monoligne
- Horodatés
- Flushés
