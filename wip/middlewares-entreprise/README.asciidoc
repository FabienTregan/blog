= Middleware d'entreprises : nous ne sommes plus en l'an 2000
Julien Kirch
v1.0, 2015-09-23

== De quoi s'agit-il ?

Quand j'ai commencé à travailler dans les années 2000, [line-through]#les dinosaures dominaient le monde# les projets étaient en train de changer.
Grâce aux tests automatisés, à l'extreme programming et aux nouveaux outils qui arrivaient comme les serveurs d'applications et Subversion, on apprenait à développer mieux et plus vite.

L'un des points qui posait problème était les middleware d'entreprises : ils nous semblaient lourds et inadaptés à nos nouvelles pratiques, et ont commencé à devenir des goulets d’étranglement.

Presque 15 ans plus tard, avec les pratiques agiles et le Devops, les pratiques ont bien changé.
Malheureusement ce n'est pas le cas pour un certains nombres d'outils : ils ont enrichis leurs fonctionnalité, mais ne se sont pas transformés.

Dans différents domaines, ces outils peuvent désormais être un vrai frein pour votre capacité à délivrer.
Il faut garder en tête qu'un environnement technique est toujours nivelé par le bas : le plus mauvais outil dicte ses contraintes à toute la chaîne.

S'il est parfois possible de contourner ces limitations, il s'agit généralement de rustines fragiles. Et rappelez-vous que les outils sont sensé vous aider et pas se mettre sur votre route pour vous empêcher de travailler.

Prendre conscience de ces limitations peut vous aider dans deux situations :

- Si vous devez choisir un nouvel outil, cela vous permettra d'être certain que vos critères d'évaluation couvrent bien ces caractéristiques. Chez Octo, lors des missions de sélections d'outils, cela fait longtemps que ces prérequis font partie des éléments critiques.
- Si vous avez déjà ces outils, cela vous permettra de vous rappeler les limites qu'il vous impose, et vous fera peut-être réaliser qu'il est temps d'en changer.

=== C'est quoi un middleware d'entreprise ?

image::easter.jpg[title="Des middleware d'entreprise dans leur habitat naturel, photo par Arian Zwegers en CC"]

Il s'agit d'un groupe aux limites assez floues mais qu'on peut délimiter par un certains nombres de caractéristiques :

- il s'agit d'outils transverses ;
- ils peuvent être structurants pour le SI suivant l'usage qui en est fait ;
- leur choix n'est pas laissé à la main de chaque projet mais est effectué de manière transverse, souvent par une cellule d'architecture et/ou l'équipe en charge de l'exploitation ;
- ils sont choisis pour durer, et donc sont souvent évalués pour leur capacité à répondre à des besoins qu'on a identifié, mais qui après coup ne se réalisent pas toujours.

Les exemples les plus courants sont les link:https://fr.wikipedia.org/wiki/Message-oriented_middleware[bus de messages], les link:https://en.wikipedia.org/wiki/Enterprise_service_bus[bus d'entreprises], les link:https://fr.wikipedia.org/wiki/Extract-transform-load[ETL], les outils d'API management et les appliances de sécurité.
Même s'il ne s'agit pas de middlewares, de nombreuses briques logicielles suivent les mêmes règles, par exemples les link:https://fr.wikipedia.org/wiki/Java_EE[serveurs d'applications] ou les technologies de virtualisation.

== Logiciels propriétaires

Les middleware d'entreprises est un des derniers bastions des logiciels propriétaires.
Le problème n'est pas le fait d'utiliser des logiciels propriétaires, mais les conséquences des pratiques de certains éditeurs sur l'utilisation des logiciels.

=== La gestion des licences

Tout d'abord il y a la gestion des licences : si nous comprenons que l'éditeur veuille s'assurer que ses logiciels soient dûment utilisés, mais il faut que cela soit fait proprement.

L'idéal est un fichier de licence fixe à copier sur les serveurs, que cela soit un fichier unique ou un fichier par environnement : avec des outils de déploiement, il n'y a pas de dégradation par rapport à un outil ouvert.

La capacité des outils de middleware à être élastique est maintenant souvent mise en avant (et on en reparlera plus bas). Si ce sujet est important pour vous, vérifiez que d'ajouter des nœuds dans un cluster ne nécessitera pas de changer en même temps le fichier de licence dans chacun des serveurs, y compris les serveurs existants.

Depuis que les link:https://fr.wikipedia.org/wiki/Dongle[dongle matériels] ont quasiment disparus, la pire situation est un "serveur de licence" que link:https://en.wikipedia.org/wiki/Phoning_home[l'outil appelle pour valider sa licence].

Deux cas se posent.

==== Serveur de licence local

Quand vous devez installer vous-même un serveur de license.

- Cela ajoute de la complexité dans le SI sans bénéfice pour vous.
- Ils sont souvent moins bien outillés et documentés que les serveurs opérationnels, les installer et les opérer est souvent plus difficile.
- Ils sont rarement prévus pour fonctionner en haute disponibilité et il s'agit donc de link:https://fr.wikipedia.org/wiki/Point_individuel_de_défaillance[SPOFs]. Quand ils sont seulement utilisés dans un but de collecte d'information cela est juste pas très professionnel. Mais quand les serveurs opérationnels doivent appeler le serveur de licence régulièrement ou lors de chaque démarrage pour pouvoir fonctionner, un serveur de licence non accessible c'est un morceau ou tout votre SI qui s'arrête.

==== Serveur hébergé par l'éditeur

Quand le serveur est hébergé par l'éditeur.

- Le même risque opérationnel se pose en cas de serveur indisponible : êtes vous prêt à vous passer de votre ESB à usage strictement interne si votre connexion internet tombe ?
- Un risque de sécurité  : sans tomber dans la paranoïa, un serveur qui fait un appel sortant que vous ne maitrisez pas est toujours dangereux. À vous d'en évaluer les conséquences.

=== Le prix

Le prix est d'abord un critère de choix pour sélectionner la solution, mais il peut aussi avoir des conséquences sur son utilisation.

==== Mutualiser les instances

Si le prix est payé par serveur, pour économiser vous aurez intérêt à diminuer le nombre d'instances.
La conséquence est souvent une tentation de mutualiser les serveurs au delà du raisonnable.
Le cas qu'on rencontre couramment est celui des serveurs d'applications Java. Les limitations du modèle J2E font que, malgré ce qu'en disent certains vendeurs, utiliser un seul serveur pour plusieurs applications pose un tas de problèmes : ressources non isolées, fuites mémoires…
Les utilisateurs qui ont le choix utilisent systématiquement un serveur par applications, les seuls qui mutualisent leurs serveurs sont ceux qui le font pour limiter leur coûts de license, et la contrepartie est de rendre leur système moins fiable.

==== Mutualiser les environements

On peut aussi être amené à mutualiser les environnements : en fonction de la pression sur les prix, on mutualisera les serveurs de plusieurs environnements au lieu de les isoler.

Les problèmes que cela pose dépendent de la manière dont la mutualisation est faite :

- Les environnements de pré-production et de production sont souvent les seuls à fonctionner en cluster, augmentant d'autant les prix. Quand ils s'executent sur les mêmes serveurs, les tests de performances effectués en pré-production risquent de faire tomber la production.
- Si les environnements de tests sont mutualisés et celui de production dédié, le risque est celui d'avoir des configuration différente dans les deux cas et donc d'avoir des régressions.

==== Deux solutions

La dernière possibilité est d'être obligé d'utiliser deux systèmes différents : un système pour les besoins "critiques", et un autre système pour les besoins "non critiques".
Cette approche repose sur l'idée est que pour les besoins les plus importants, seule peut convenir une solution vendue par un grand éditeur.
Il s'agit d'une survivance des années 2000 où les solutions open-souces ou vendues par des petits éditeurs étaient souvent moins avancées, et leur support réputé moins fiable.
Étant donné le prix de la solution critique il n'est malheuresement pas possible de l'utiliser partout.
Il est donc nécessaire de choisir une deuxième solution pour les autres besoins, ce qui complexifie votre système et augmente son coût.

== Architecture

Après les question de licenses l'architecture.

=== Haute disponibilité

La haute disponibilité fait désormais partie des fonctionalités standard exigées des produits, mais une subtilité est tout de même à vérifier :
dans le cas où en plus des serveurs d'execution, existe un serveur d'administration, celui-ci peut ne pas être en haute disponibilité.
Même si la criticité est moindre (quand le serveur d'administration est indisponible, le système devrait continuer à fonctionner le temps qu'il soit réparé), il s'agit tout de même d'un point de fragilité.

=== Élasticité

L'autre élément à examiner est l'élasticité.
Même si vous n'avez pas besoin d'ajouter ou de supprimer des instances à chaque instant, une augmentation de traffic peut nécessiter d'ajouter une instance d'ici quelques mois et il est important d'en connaître les impacts.
Si beaucoup de produits revendiquent désormais cette propriété, certains prennent des libertés avec sa définition courante :
selon les outils, changer le nombre d'instance peut être totalement transparent, diminuer les performance pendant le rééquilibrage de données, ou même nécéssiter de redémarrer tous les serveurs pour propager une configuration.

=== Physique ou virtuel ?

Pour l'hébergement la virtualisation est désormais la règle.
Un logiciel qui nécessite d'être hébergé sur du bare metal aura donc besoin d'une bonne raison pour cela.
Encourager l'utilisation du bare metal pour gagner des performances est un chose, la forcer en est une autre.

En dehors de quelques systèmes de niche (sécurité, très haute performance), les appliances physiques sont désormais une espèce disparue et avec eu le besoin de déplacer des serveurs et de recabler des baies quand une configuration changeait.
Le remplacement par des appliances virtuelles supprimer la contrainte physique, mais pas les autres :

- vous ne pourrez pas monitorer cette brique de la même manière que les autres ;
- il faut faire confiance à l'éditeur pour maintenir le système à jour et sécurisé, ce qui devient de moins en moins acceptable avec la multiplication des failles publiées.

Il s'agit donc toujourd d'un pis-aller.

Vérifiez que l'image est compatible avec link:https://help.ubuntu.com/community/CloudInit[cloud-init], ce qui vous permettra de l'intégrer facilement dans vos outils de provisionning, sinon un coût et un délai suplémentaire est à prévoir.

L'avenir dans ce domaine est probablement d'aller vers du Docker : l'éditeur gardera la main sur l'installation et les projets  .

== Déploiement et configuration

Pour l'installation l'outil doit être fourni sous forme d'un package installable adapté à votre distribution (deb, apt, rpm…).
Pour être facilement exploitable, il doit respecter la normer link:https://en.wikipedia.org/wiki/Linux_Standard_Base[LSB] : cela vous permettra par exemple de trouver facilement les différents fichiers.

Pour la configuration du socle du logiciel, des recettes de déploiements type Chef / Puppet / Ansible sont désormais la norme.
S'ils sont fournis pour un outil qui n'est pas celui que vous utilisez, le portage ne devrait pas compliqué à condition que l'éditeur ait bien fait son travail.

Pour être facilement utilisables, les fichiers de configurations doivent respecter certains critères :

- ils doivent être lisibles et éditables facilement par des humains, pas question par exemple d'avoir des fichiers contenant des objets java séralisés en XML, ou du XML avec des champs CDATA ;
- chaque variable doit être présente à un seul endroit, gare par exemple aux outils sous forme de composants où chacun a son fichier de configuration propre qui duplique les mêmes éléments sans possibilité de partager les parties identiques.

Le cas à exclure absolument est celui de configuration

- Fichiers de configuration templatisables dans une syntaxe lisible
  - Pas dans un format binaire ou difficile à modifier (type objet java sérailisé)
- les variables à un seul endroit
- Diffables

Passage d'un environement à l'autre: obligé de refaire les mêmes manipulations avec risque d'erreur

== Développement en équipe et gestion de version

Sur le papier, une des fonctionalités les plus mises en avant des middleware d'entreprise était d'avoir un outil graphique permettant d'utiliser l'outil sans utiliser de terminal ou d'éditer de fichiers.

Malheuresement l'effet waou passé, les ennuis commencent.

D'abord sous prétexte de ne pas avoir besoin d'éditer de fichiers, les fichiers générés par ces outils sont souvent des fichiers binaires.
Il est donc impossible d'éditer les fichiers directement et tout doit donc passer par l'éditeur fourni.
Tous les workflows automatiques reposant sur la capacité à modifier des fichiers tectuels sont inapliquables, comme le report de modifications entre branches via un outil de gestion de version ou entre environnements via un outil de déploiement.
Remplacer ces opérations qui s'automatisent facilement par des opérations manuelles coûte du temps et pose des risques : vous pouvez dire adieu à votre pipeline de déploiement automatisé et bonjour aux régressions.
Même si on préférerait ne jamais avoir eu cette idée, on peut s'en sortir en utilisant un outil comme link:http://www.seleniumhq.org[Selenium] ou link:http://www.sikuli.org[Sikuli] pour piloter la saisie de la configuration dans l'outil graphique, mais il s'agit d'une approche coûteuse et fragile à n'utiliser qu'en dernier ressort.

Ensuite les outils utilisant cette approche sont conçus pour être utilisés par une seule personne à la fois.
Dans les organisations où un groupe de personne bien identifié est en charge de chaque outil, cette limite est acceptable.
On fait une demande à l'équipe en question, qui s'en charge dès qu'elle le peut, en jonglant entre les priorités et ses resources souvent limitées.
Avec le raccourcicement des cycles de développement, ce type de fonctionnement devient invivable : tout est fait pour limiter la dépendance entre équipes et favoriser l'autonomie des équipes.
Ce type d'outil devient donc inadapté : pas question de devoir réserver son tour pour avoir le droit de configurer un outil.
Les middlerware étant souvent transversers, impossible non plus d'avoir une instance par équipe, on est donc coincé.

== Test

Facilité de tester de manière automatisé.

== Exploitabilité

=== Monitoring

Pas de polling pour avoir l'info
Une API
Un format standard (JMX, SNMP)

=== Log

- Connecteur standard : syslog au minimum
- Faciles à parser et univoques, JSON monoligne
- Horodatés
- Flushés
