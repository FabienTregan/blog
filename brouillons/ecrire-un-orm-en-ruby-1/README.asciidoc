= Écrire un ORM en Ruby partie 1{nbsp}: structure
Julien Kirch
v0.1, 2020-05-10
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

Les ORMs sont probablement les outils les plus complexes auxquels ont a affaire directement quand on commence à développer.

De ce fait, on peut avoir du mal à imaginer comment ils peuvent bien fonctionner, et peuvent donner l'impression d'être presque magiques.

Impression souvent renforcé quand on lit leur code, souvent assez dense et utilisant des constructions différentes de celles du code applicatif.

Cette situation peut avoir deux conséquences :

- les personnes ne se sentent pas à l'aise quand elles utilisent des ORMs{nbsp}
- les personnes ont un avis négatif des ORMs alors qu'il n'est pas basé sur des faits concrets (qu'on ait un avis négatif sur les ORMs basés sur des éléments objectifs ne me pose pas de problèmes).

Pour lutter contre cela, je vous propose une série d'articles décrivant pas à pas comment écrire un ORM SQL minimal en Ruby, par minimal j'entends un ORM capable de faire de l'insertion, du requêtage simple et gérer des relations entre objets.

Mon objectif est qu'après avoir lu ces articles, vous ayez le sentiment de comprendre comment ils fonctionnent, et que de ce fait ils ne vous fassent plus peur.

== Un exemple mono-base

La plupart des ORMs SQL sont compatibles avec de nombreuses de base de données.
Cette compatibilité s'implémente généralement en permettant que toutes les méthodes de l'ORM soient surchargeables en fonction des spécificités de chaque base.

Par exemple pour une classe de génération de requète `QueryBuilder`, on aura ainsi un `SQLiteQueryBuilder`, un `PostgreSQLQueryBuilder`{nbsp}…

La difficulté est de parvenir à structurer le code pour pouvoir prendre en compte les spécificités de chaque base sans que cela tourne au plat de spaghetti, sachant que suivant les bases ces particularité ne sont pas toutes au mêmes endroits.

Mais cela ne porte pas à conséquence sur le fonctionnement général de l'outil.
Mon exemple sera donc mono-base et ciblera SQLite car elle fournit tout ce dont j'ai besoin et qu'elle est facile à installer.

== Génération de code à froid plutôt qu'à chaud

Contrairement à des ORMs comme link:https://guides.rubyonrails.org/active_record_basics.html[Active Record] ou link:http://sequel.jeremyevans.net[Sequel], l'ORM que je vais implémenter utilisera de la génération de code à froid&#8201;—{nbsp} c'est-à-dire sous forme de fichiers{nbsp}—&#8201; plutôt qu'à chaud sous forme de code généré à l'execution.

Générer du code dans des fichiers permet d'examiner les comportements sans avoir à débuguer, et permet un meilleur support de la part des outils.

Mon avis est que ce type d'approche est préférable à la génération de code à chaud sauf très bonne raison.

Quand j'utilise Active Record et que j'ai besoin de poser des breakpoints et d'examiner les objets en mémoire pour connaître les méthodes disponibles sur un modèle ça me rend triste.

En Ruby, générer du code à l'execution est facile, ce qui est bien, mais je pense que la communauté a tendance à parfois trop l'utiliser, surtout que par ailleurs le rechargement de code à chaud fonctionne très bien.

== Le début

Le code (framework et code d'exemple) sera dans un projet unique, et ne sera pas packagé sous forme d'une gem.

Le faire ajouterait pas mal de code et un peu de complexité sans que cela apporte quelque chose.

=== Les dépendances

Tout d'abord il faut fixer la version de Ruby, je vais utiliser la dernière à date par principe.

.ruby-version 
[source]
----
2.7.1
----

Ensuite pour les bibliothèques, en plus de la gem permettant d'utiliser SQLite je vais me servir de Rake pour définir la tâche de génération de code.

.Gemfile
[source]
----
source "https://rubygems.org"

gem "rake", "~> 12.0"
gem "sqlite3", "~> 1.4"
----

== Comme exemple{nbsp}:un jeu de construction

Dans la suite, je vais prendre comme exemple un jeu de construction.

Ce jeu de construction est composé des différents types de briques (`Brick`), qui sont chacun d'une certaine couleur (`Color`).
Des modèles à construire (`Kit`) sont constitués d'un ensemble de types de briques chacun présent un certain nombre de briques (tant de briques d'une sorte, tant de briques d'une autre sorte), la relation modèle - type de brique étant modélisé par un `KitBrick`.

Voici la structure SQL{nbsp} correspondante:

.structure.sql
[source,sql]
----
CREATE TABLE 'color' (
  'id' INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,

  'name' TEXT NOT NULL
);

CREATE UNIQUE INDEX idx_color_unique 
  ON color('name');

CREATE TABLE 'brick' (
  'id' INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,

  'name' TEXT NOT NULL,
  'description' TEXT NOT NULL,
  'color_id' INTEGER NOT NULL,

  FOREIGN KEY('color_id') REFERENCES 'color'('id')
);

CREATE TABLE 'kit' (
  'id' INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  'name' TEXT NOT NULL,
  'description' TEXT NOT NULL
);

CREATE TABLE 'kit_brick' (
  'id' INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,

  'kit_id' INTEGER NOT NULL,
  'brick_id' INTEGER NOT NULL,
  'quantity' INTEGER NOT NULL,

  FOREIGN KEY('kit_id') REFERENCES 'kit'('id'),
  FOREIGN KEY('brick_id') REFERENCES 'brick'('id')
);
CREATE UNIQUE INDEX 'idx_kit_brick_uniqu' 
  ON 'kit_brick'('kit_id', 'brick_id');
----

== Le début des classes de modèles

Pour générer les classes de modèle, je vais utiliser un fichier de configuration.
Au début il contiendra seulement les noms des modèles et les noms des tables correspondantes.

La syntaxe s'inspire des DSL de configuration qu'on trouve dans Rails{nbsp}:

.schema.rb
[source,ruby]
----
define_model 'Color' do |model_definition|
  model_definition.table 'color'
end

define_model 'Brick' do |model_definition|
  model_definition.table 'brick'
end

define_model 'Kit' do |model_definition|
  model_definition.table 'kit'
end

define_model 'KitBrick' do |model_definition|
  model_definition.table 'kit_brick'
end
----

La capacité d'utiliser des noms de table par défaut en les déduisants des noms des classes demanderait un peu plus de code sans changer le fonctionnement d'ensemble.

Je vais 


.generator.rb
[source,ruby]
----
class ModelDefinition

  MODELS_DEFINITIONS = []

  attr_reader :name, :table_name
  
  # @param [String] name
  def initialize(name)
    @name = name
    MODELS_DEFINITIONS << self
  end

  # @param [String]
  # @return [void]
  def table(table_name)
    @table_name = table_name
  end
end

# @param [String] model_name
# @yieldparam [ModelDefinition] model_definition
# @yield [model_definition]
def define_model(model_name, &block)
  puts "Defining model [#{model_name}]"
  model_definition = 
    ModelDefinition.new(model_name)
  block.yield(model_definition)
end

require_relative 'schema'
----

.generator.rb
[source,ruby]
----
require 'erb'

erb = ERB.new(IO.read('models.rb.erb'))

models_code = ModelDefinition::MODELS_DEFINITIONS.
    map do |model|
  erb.result_with_hash(model: model)
end

IO.write(
    'models.rb',
    models_code.
        join("\n\n").
        # Clear lines with only spaces
        gsub(/\n\s*\n/, "\n\n").
        # When more than 2 lines break only use 2
        gsub(/\n{2,}/, "\n\n")
)
----

.models.rb.erb
[source]
----
class <%= model.name %>

  # @return [String]
  def self.table_name
      '<%= model.table_name %>'
  end
end
----

.Rakefile
[source,ruby]
----
desc 'Generate the models from the schema'
task :generate_models do
  require_relative 'generator'
end
----

[source,bash]
----
$ rake generate_models 
Defining model [Color]
Defining model [Brick]
Defining model [Kit]
Defining model [KitBrick]
----

.models.rb
[source,ruby]
----
class Color < Model

  # @return [String]
  def self.table_name
      'color'
  end
end

class Brick < Model

  # @return [String]
  def self.table_name
      'brick'
  end
end

class Kit < Model

  # @return [String]
  def self.table_name
      'kit'
  end
end

class KitBrick < Model

  # @return [String]
  def self.table_name
      'kit_brick'
  end
end
----