= Écrire un ORM en Ruby partie 1{nbsp}: structure
Julien Kirch
v0.1, 2020-05-10
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

Les ORMs sont probablement les outils les plus complexes auxquels ont a affaire directement quand on commence à développer.

De ce fait, on peut avoir du mal à imaginer comment ils peuvent bien fonctionner, et peuvent donner l'impression d'être presque magiques.

Impression souvent renforcé quand on lit leur code, souvent assez dense et utilisant des constructions différentes de celles du code applicatif.

Cette situation peut avoir deux conséquences :

- les personnes ne se sentent pas à l'aise quand elles utilisent des ORMs{nbsp}
- les personnes ont un avis négatif des ORMs alors qu'il n'est pas basé sur des faits concrets (qu'on ait un avis négatif sur les ORMs basés sur des éléments objectifs ne me pose pas de problèmes).

Pour lutter contre cela, je vous propose une série d'articles décrivant pas à pas comment écrire un ORM minimal en Ruby, par minimal j'entends un ORM capable de faire de l'insertion, du requêtage simple et gérer des relations entre objets.

Mon objectif est qu'après avoir lu ces articles, vous ayez le sentiment de comprendre comment ils fonctionnent, et que de ce fait ils ne vous fassent plus peur.

== Génération de code à froid plutôt qu'à chaud

Contrairement à des ORMs comme link:https://guides.rubyonrails.org/active_record_basics.html[Active Record] ou link:http://sequel.jeremyevans.net[Sequel], l'ORM que je vais implémenter utilisera de la génération de code à froid&#8201;—{nbsp} c'est-à-dire sous forme de fichiers{nbsp}—&#8201; plutôt qu'à chaud sous forme de code généré à l'execution.

Générer du code dans des fichiers permet d'examiner les comportements sans avoir à débuguer, et permet un meilleur support de la part des outils.

Mon avis est que ce type d'approche est préférable à la génération de code à chaud sauf très bonne raison.

Quand j'utilise Active Record et que j'ai besoin de poser des breakpoints et d'examiner les objets en mémoire pour connaître les méthodes disponibles sur un modèle ça me rend triste.

En Ruby, générer du code à l'execution est facile, ce qui est bien, mais je pense que la communauté a tendance à parfois trop l'utiliser, surtout que par ailleurs le rechargement de code à chaud fonctionne très bien.

== Le début


.Gemfile
[source]
----
source "https://rubygems.org"

gem "rake", "~> 12.0"
gem "sqlite3", "~> 1.4"
----

.structure.sql
[source,sql]
----
CREATE TABLE 'color' (
  'id' INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,

  'name' TEXT NOT NULL
);

CREATE UNIQUE INDEX idx_color_unique ON color('name');

CREATE TABLE 'brick' (
  'id' INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,

  'name' TEXT NOT NULL,
  'description' TEXT NOT NULL,
  'color_id' INTEGER NOT NULL,

  FOREIGN KEY('color_id') REFERENCES 'color'('id')
);

CREATE TABLE 'kit' (
  'id' INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  'name' TEXT NOT NULL,
  'description' TEXT NOT NULL
);

CREATE TABLE 'kit_bricks' (
  'id' INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,

  'kit_id' INTEGER NOT NULL,
  'brick_id' INTEGER NOT NULL,
  'quantity' INTEGER NOT NULL,

  FOREIGN KEY('kit_id') REFERENCES 'kit'('id'),
  FOREIGN KEY('brick_id') REFERENCES 'brick'('id')
);
CREATE UNIQUE INDEX 'idx_kit_brick_uniqu' ON 'kit_bricks'('kit_id', 'brick_id');
----

.schema.rb
[source,ruby]
----
define_model 'Color' do |model_definition|
  model_definition.table 'color'
end

define_model 'Brick' do |model_definition|
  model_definition.table 'brick'
end

define_model 'Kit' do |model_definition|
  model_definition.table 'kit'
end

define_model 'KitBricks' do |model_definition|
  model_definition.table 'kit_bricks'
end
----

.generator.rb
[source,ruby]
----
class ModelDefinition

  MODELS_DEFINITIONS = []

  attr_reader :name, :table_name
  
  # @param [String] name
  def initialize(name)
    @name = name
    MODELS_DEFINITIONS << self
  end

  # @param [String]
  # @return [void]
  def table(table_name)
    @table_name = table_name
  end
end

# @param [String] model_name
# @yieldparam [ModelDefinition] model_definition
# @yield [model_definition]
def define_model(model_name, &block)
  puts "Defining model [#{model_name}]"
  model_definition = ModelDefinition.new(model_name)
  block.yield(model_definition)
end

require_relative 'schema'

require 'erb'

erb = ERB.new(IO.read('models.rb.erb'))

models_code = ModelDefinition::MODELS_DEFINITIONS.map do |model|
  erb.result_with_hash(model: model)
end

IO.write(
    'models.rb',
    models_code.
        join("\n\n").
        # Clear lines with only spaces
        gsub(/\n\s*\n/, "\n\n").
        # When more than 2 lines break only use 2
        gsub(/\n{2,}/, "\n\n")
)
----

.models.rb.erb
[source]
----
class <%= model.name %>

  # @return [String]
  def self.table_name
      '<%= model.table_name %>'
  end
end
----

.Rakefile
[source,ruby]
----
desc 'Generate the models from the schema'
task :generate_models do
  require_relative 'generator'
end
----

[source,bash]
----
$ rake generate_models 
Defining model [Color]
Defining model [Brick]
Defining model [Kit]
Defining model [KitBricks]
----

.models.rb
[source,ruby]
----
class Color < Model

  # @return [String]
  def self.table_name
      'color'
  end
end

class Brick < Model

  # @return [String]
  def self.table_name
      'brick'
  end
end

class Kit < Model

  # @return [String]
  def self.table_name
      'kit'
  end
end

class KitBricks < Model

  # @return [String]
  def self.table_name
      'kit_bricks'
  end
end
----