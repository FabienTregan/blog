= Writing a "`Baba Is You`" solver, part 1: reading levels
Julien Kirch
v0.1, 2019-05-05
:article_lang: en
:ignore_files: content.txt, first-level.png, graph.mmd, levelreader1.java, levelreader2.java, levelreadertest.java, mvn.txt, tiles.java, tiles.txt
:article_image: first-level.png
:source-highlighter: pygments
:pygments-style: friendly
:article_description: It was a while since the last time I took a questionable decision

link:https://hempuli.com/baba/[Baba Is You] is a great puzzle game with a more-than-usual complex gameplay since manipulating the game rules is part of the game.

I think it's a good candidate to write a solver for, and to write some articles documenting how I'm doing it.
I'm writing the articles while coding the solver and not as a post-mortem, so expect some bad design and implementation decisions along the way.

As I've explained link:../solveurs/[in a previous article] (in French), a puzzle solver rely on a loop used to iterate until a solution is found.

image::graph.svg[width=731,height=513]

The first step is to be able to initialize the loop, which means reading the levels from disk.

== Create the project

First thing is to bootstrap the project.

A solver has often complex data types and you need to do much refactoring so a language with static types is great, and a fast language is nice to have to make things faster, so my tool of choice for this case is Java.

So first create the project:
[source,bash]
----
include::mvn.txt[]
----

Then add the required files (`LICENSE.txt` ‚Ä¶) and push it to link:https://github.com/archiloque/babaisyousolver[GitHub].

== Designing how to read levels

For my other solvers, reading the levels link:https://github.com/archiloque/rgbexpress/blob/master/src/main/java/net/archiloque/rgbexpress/MapElement.java#L12[relied on a fixed list of elements with an associated character].

For Baba, the number of possible tiles seem large from the levels I've played so I'm thinking of using another strategy:

. Define all the possible tiles
. For each level, declare which tiles match with each character, for the tiles to be used in the level

Levels use a square grid, and there is at most one item per tile in the starting position.

image::first-level.png[title="The first level"]

What I'd like the files to be:

.levels/1/tiles.txt
[source]
----
include::tiles.txt[]
----

.levels/1/content.txt
[source]
----
include::content.txt[]
----

Note: I'd like to rely on emojis, like using üêá to represents baba or üèÅ for the flag, but the way macOS deal with emoji don't make them monospace friendly, so it breaks the visual aspect of the level files and editing them becomes a pain.

I declare all the tiles used by the first level, as a `String` to be referenced by the level, and as an `int` to be referenced by the game:

.Tiles.java
[source,java]
----
include::tiles.java[]
----

Perhaps later this file will become a pain to maintain so I'll end up putting the content in a config file and generate the Java code from it but for now I prefer to use a simpler way.

Drafting the API of how to read the level files:

.LevelReader1.java
[source,java]
----
include::levelreader1.java[]
----

Calling `LevelReader#readLevel` will return a `LevelReader.LevelReaderResult` containing the data in a ready to use format.

All the data will use arrays instead of arrays of arrays: it simplifies the copying, and makes everything faster.

Representing a position as a single integer can also make things simpler when you need to pass or return info since it use a single value instead of an object that need to be created each time.

To convert a line/column coordinate to a position used in a flat array and back you need to use this code:

[source,java]
----
int position = (indexLine * levelWidth) + indexColumn;

int indexLine = position / levelWidth;
int indexColumn = position % levelWidth;
----

I use link:https://www.jetbrains.com/help/idea/annotating-source-code.html[JetBrains's annotations] extensively to handle nullability in my code, when I code with link:https://www.jetbrains.com/idea/[Idea] it's an acceptable substitute of have it build into the language.

== Add some code

First the tests (just showing the names):

.LevelReaderTest.java
[source,java]
----
include::levelreadertest.java[]
----

There's a bunch of test for error cases because I hate to debug the code when there's an error with the level files so the error are as explicit as possible.

Then fill the content of the reader:

.LevelReader.java
[source,java]
----
include::levelreader2.java[]
----

Now the code read a level from disk and the next article will start implementating the solving logic.