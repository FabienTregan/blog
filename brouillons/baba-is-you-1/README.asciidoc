[#baba-is-you-1]
ifeval::["{doctype}" == "book"]
= Part 1: reading levels
endif::[]
ifeval::["{doctype}" != "book"]
= Writing a "`Baba Is You`" solver, part 1: reading levels
endif::[]
:author: Julien Kirch
:revnumber: v0.1
:docdate: 2019-05-09
:article_lang: en
:ignore_files: content.txt, graph1.mmd, graph1.png, levelreader1.java, levelreader2.java, levelreadertest.java, mvn.txt, tiles.java, tiles.txt
:article_image: first-level1.png
ifndef::source-highlighter[]
:source-highlighter: pygments
:pygments-style: friendly
endif::[]
:article_description: It was a while since the last time I took a questionable decision
:figure-caption!:

link:https://hempuli.com/baba/[Baba Is You] is a great puzzle game with a more-than-usual complex gameplay since manipulating the game rules is part of the game.

I think it's a good candidate to write a solver for, and to document how I'm doing it.

I'm writing while coding the solver and not as a post-mortem, so expect some bad design and implementation decisions along the way.

As I've explained link:../solveurs/[in a previous article] (in French), a puzzle solver rely on a loop used to iterate until a solution is found.

ifeval::["{doctype}" == "book"]
image::../baba-is-you-1/graph1.png[width=784,height=468,align="center"]
endif::[]
ifeval::["{doctype}" != "book"]
image::../baba-is-you-1/graph1.svg[width=784,height=468,align="center"]
endif::[]

The first step is to be able to initialize the loop, which means reading the levels from disk.

== Create the project

First thing is to bootstrap the project.

A solver has often complex data types and you need to do much refactoring so a language with static types is great, and a fast language is nice to have to make things faster, so my tool of choice for this case is Java.

So first create the project:
[source,bash]
----
include::mvn.txt[]
----

Then add the required files (`LICENSE.txt` ‚Ä¶) and push it to link:https://github.com/archiloque/babaisyousolver[GitHub].

== Read levels

For my other solvers, reading the levels link:https://github.com/archiloque/rgbexpress/blob/master/src/main/java/net/archiloque/rgbexpress/MapElement.java#L12[relied on a fixed list of elements with an associated character].

For Baba, the number of possible tiles seems large from the levels I've played so I'm thinking of using another strategy:

. Define all the possible tiles
. For each level, declare which tiles match with each character, for the tiles to be used in the level

Levels use a square grid, and there is at most one item per tile in the starting position.

image::../baba-is-you-1/first-level1.png[title="The first level",align="center",width=293,height=342]

What I'd like the files to be:

.levels/00/tiles.txt
[source]
----
include::tiles.txt[]
----

.levels/00/content.txt
[source]
----
include::content.txt[]
----

Note: I'd like to rely on emojis, like using üêá to represents baba or üèÅ for the flag, but the way macOS deal with emoji don't make them monospace friendly, so it breaks the visual aspect of the level files and editing them becomes a pain.

I declare all the tiles used by the first level, as a `String` to be referenced by the level, and as an `int` to be referenced by the game:

.Tiles.java
[source,java]
----
include::tiles.java[]
----

I use ``int``s instead of enum types for this kind of data for two reasons :

* they took less memory, and it makes a big difference when you have to store many levels;
* you can use the `int` as array index to retrieve data instead of using a `Hash`, which makes it much faster.

I have experienced both in my previous solvers.

You loose some type checking this way and makes code a bit less readable but it's an acceptable downside for me.

Perhaps later this file will become a pain to maintain so I'll end up putting the content in a config file and generate the Java code from it but for now I prefer to use a simpler way.

Drafting the API of how to read the level files:

.LevelReader1.java
[source,java]
----
include::levelreader1.java[]
----

Calling `LevelReader#readLevel` will return a `LevelReader.LevelReaderResult` containing the data in a ready to use format.

All the data will use arrays instead of arrays of arrays: it simplifies the copying, and makes everything faster.

Representing a position as a single integer can also make things simpler when you need to pass or return info since it use a single value instead of an object that need to be created each time.

To convert a line/column coordinate to a position used in a flat array and back you need to use this code:

[source,java]
----
int position = (indexLine * levelWidth) + indexColumn;

int indexLine = position / levelWidth;
int indexColumn = position % levelWidth;
----

I use link:https://www.jetbrains.com/help/idea/annotating-source-code.html[JetBrains's annotations] extensively to handle nullability in my code, when I code with link:https://www.jetbrains.com/idea/[Idea] it's an acceptable substitute of have it build into the language.

== Add some code

First the tests (just showing the names):

.LevelReaderTest.java
[source,java]
----
include::levelreadertest.java[]
----

There's a bunch of tests for error cases because I hate to debug the code when there's an error with the level files so the error are as explicit as possible.

Then fill the content of the reader:

.LevelReader.java
[source,java]
----
include::levelreader2.java[]
----

Now the code reads a level from disk and the next part will start implementing the solving logic.