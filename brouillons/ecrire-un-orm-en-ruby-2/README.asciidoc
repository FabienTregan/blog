= Écrire un ORM en Ruby partie 2{nbsp}: récupération des champs, insertion et sélection
Julien Kirch
v0.1, 2020-05-10
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

Ceci est le deuxième article d'une série de quatre décrivant pas à pas comment écrire un ORM SQL minimal en Ruby.

Après link:../ecrire-un-orm-en-ruby-1/[le premier article] où j'ai posé les bases de l'outil, je vais ici ajouter ce qu'il manque pour faire les premières requètes.

== Des modèles avec des champs

La première étape va s'intéresser aux champs des modèles.

Il serait possible de les paramétrer via le fichier de configuration de schema `schema.rb`, mais je vais plutôt utiliser les métadonnées de la base de données, car c'est une bonne occasion de donner un aperçu de leur fonctionnement.

En effet même si tous les ORMs n'utilisent pas les métadonnées beaucoup le font, et comprendre que cela n'est pas si compliquée est bien utile.

Même si cela ne fait pas partie du standard SQL, la majorités des bases de données de ce type fournissent des requéter les métadonnées des bases telles que les tables, les index{nbsp}…

Suivant les systèmes on pourra utiliser du SQL&#8201;—{nbsp}en intérrogeant des tables particulières{nbsp}—&#8201;ou des commandes spécifiques.

Avec SQLite, l'accès aux métadonnées se fait via des link:https://www.sqlite.org/pragma.html[la commandes PRAGMA].


[source]
----
$ sqlite3 orm-ruby.sqlite
sqlite> .header on -- Active l'affichage des noms de colonnes dans les requêtes
sqlite> pragma table_info('color'); -- Donne des informations sur la table `color`

cid|name|type|notnull|dflt_value|pk
0|id|INTEGER|1||1
1|name|TEXT|1||0
----

Pour chaque colonne `table_info` nous donne son identifiant, son nom, son type, si elle est nullable, son éventuelle valeur par défaut, et si il s'agit de la clé primaire de la table.

Avec la gem sqlite3, la méthode `SQLite3::Database#table_info` fait l'appel la pragma et renvoie le résultat sous une forme accessible.

Pour ajouter les colonnes disponibles dans chaque table, commençons par définir une classe `ColumnDefinition` qui contiendra les informations qui nous intéressent, à savoir le nom et le type de la colonne.

.generator.rb
[source,ruby]
----
class ColumnDefinition

  attr_reader :name, :type

  # @param [String] name
  # @param [String] type
  def initialize(name, type)
    @name = name
    @type = type
  end

end
----

Ensuite, je dois récupérer les colonnes de chaque table.
L'endroit le plus simple est de le faire juste avant de créer les classes de modèles, alors qu'on est déjà en train d'itérer sur chaque modèle, on pourra alors passer la liste des colonnes au template.

Mais pour commencer, il faut se connecter à la base de donnée.

.generator.rb
[source,ruby]
----
DATABASE = SQLite3::Database.new('orm-ruby.sqlite')
----

puis{nbsp}:

.generator.rb
[source,ruby]
----
models_code = ModelDefinition::MODELS_DEFINITIONS.map do |model|
  # List the columns definitions
  columns_definitions = DATABASE.table_info(model.table_name).collect do |column_info|
    column_name = column_info['name']
    column_type = column_info['type']
    ColumnDefinition.new(column_name, column_type)
  end
  erb.result_with_hash(model: model, columns_definitions: columns_definitions)
end
----

Dans le template, `columns_definitions` contient alors la liste des `ColumnDefinition` prêt à l'emploi.

Presque prêt à l'emploi car il reste une subtilité{nbsp}: `table_info` renvoie les types SQL des colonnes (ou plus précisément le type SQLite) comme `TEXT`, pour pouvoir l'utiliser dans le code je dois le transformer en types Ruby comme `String`.

Pour se faire, nous allons utiliser une `Hash` pour faire la conversion entre les deux.

.generator.rb
[source,ruby]
----
SQLITE_TYPE_TO_RUBY_CLASS = {
    'INTEGER' => 'Integer',
    'TEXT' => 'String'
}
----

Elle ne contient que les types que l'on va rencontrer dans notre exemple, il sera ensuite possible de l'enrichir en fonction des besoins.

En modifiant le code pour utiliser `SQLITE_TYPE_TO_RUBY_CLASS`, cela donne :

.generator.rb
[source,ruby]
----
models_code = ModelDefinition::MODELS_DEFINITIONS.map do |model|
  # List the columns definitions
  columns_definitions = DATABASE.table_info(model.table_name).collect do |column_info|
    column_name = column_info['name']
    sql_type = column_info['type']
    ruby_type = SQLITE_TYPE_TO_RUBY_CLASS[sql_type]
    ColumnDefinition.new(column_name, ruby_type)
  end
  erb.result_with_hash(model: model, columns_definitions: columns_definitions)
end
----

Avec le nom et le type de chaque colonne, je vais pouvoir générer les getter et les setters en itérant sur les `ColumnDefinition` dans le template{nbsp}:

.models.erb.rb
[source]
----
class <%= model.name %> < Model

  # @return [String]
  def self.table_name
      '<%= model.table_name %>'
  end

  <% columns_definitions.each do |column_definition| %>
  <% column_name = column_definition.name %>
  <% column_type = column_definition.type %>
  # @return [<%= column_type %>]
  def <%= column_name %>
    @<%= column_name %>
  end

  # @param [<%= column_type%>] <%= column_name %>
  # @return [void]
  def <%= column_name %>=(<%= column_name %>)
    @<%= column_name %> = <%= column_name %>
  end
  <% end %>

end
----

Ce qui donne ce résultat{nbsp}:

.models.rb
[source,ruby]
----
class Color < Model

  # @return [String]
  def self.table_name
      'color'
  end

  # @return [Array<String>]
  def self.columns
      ["id", "name"]
  end
  
  # @return [Integer]
  def id
    @id
  end

  # @param [Integer] id
  # @return [void]
  def id=(id)
    @id = id
  end
  
  # @return [String]
  def name
    @name
  end

  # @param [String] name
  # @return [void]
  def name=(name)
    @name = name
  end
end
# …
----

On peut voir ici l'intérêt de la génération de code à froid car on peut directement consulter les méthodes disponibles avec leurs informations de type.

En utilisant un IDE, on peut même disposer de l'autocompletion.

Je ne l'utilise pas dans mon exemple, mais l'information de nullabilité des colonnes pourrait servir pour renseigner la nu

.model.rb
[source,ruby]
----
require 'sqlite3'

class Model

  DATABASE = SQLite3::Database.new('orm-ruby.sqlite')

  # @abstract
  # @return [String]
  def self.table_name
    raise NotImplementedError
  end

  # @abstract
  # @return [Array<String>]
  def self.columns
    raise NotImplementedError
  end

  # @return [String]
  def self.quoted_table_name
    SQLite3::Database.quote(table_name)
  end

  # @return [void]
  def insert
    columns_names_except_id = self.class.columns.
        select { |column| column != 'id' }

    quoted_columns_names_except_id = columns_names_except_id.
        map { |column_name| SQLite3::Database.quote(column_name) }

    columns_values_except_id = columns_names_except_id.
        map { |column_name| self.send(column_name) }

    # Query looks like
    # INSERT INTO table_name
    #   (column_name_1, column_name_2, …)
    #   VALUES (?, ?, …)
    DATABASE.execute(
        "INSERT INTO #{self.class.quoted_table_name} " +
            "(#{quoted_columns_names_except_id.join(', ')}) " +
            "VALUES (#{Array.new(columns_names_except_id.length, '?').join(', ')})",
        columns_values_except_id
    )
    self.id = DATABASE.last_insert_row_id
  end
end
----

.script.rb
[source,ruby]
----
require_relative 'model'
require_relative 'models'

color = Color.new
color.name = 'Black'
color.insert

brick = Brick.new
brick.color_id = color.id
brick.name = 'Awesome brick'
brick.description = 'This brick is awesome'
brick.insert
----

[source,bash]
----
$bundle exec ruby script.rb
$ sqlite3 orm-ruby.sqlite

sqlite> select * from color;

1|Black

sqlite> select * from brick;

1|Awesome brick|This brick is awesome|1
----

.model.rb
[source,ruby]
----
class Model
  # @return [Array]
  def self.all
    quoted_columns_names = columns.
        map { |column_name| SQLite3::Database.quote(column_name) }

    # Query looks like
    # SELECT column_name_1, column_name_2, …
    #   FROM 'table_name'
    DATABASE.execute(
        "SELECT #{quoted_columns_names.join(', ')} " +
            "FROM #{quoted_table_name}"
    ).map do |result_row|
      model_instance = self.new
      columns.each_with_index do |column, column_index|
        model_instance.send("#{column}=", result_row[column_index])
      end
      model_instance
    end
  end
end
----

.model.rb
[source,ruby]
----
class Model
  # @return [void]
  def self.truncate
    DATABASE.execute("DELETE FROM #{quoted_table_name}")
  end
end
----

.script.rb
[source,ruby]
----
require_relative 'model'
require_relative 'models'

Brick.truncate
Color.truncate

black = Color.new
black.name = 'Black'
black.insert

yellow = Color.new
yellow.name = 'Yellow'
yellow.insert

brick = Brick.new
brick.color_id = black.id
brick.name = 'Awesome brick'
brick.description = 'This brick is awesome'
brick.insert

puts '# All colors'
Color.all.each do |color|
  puts color.id
  puts color.name
end

puts '# All Bricks'
Brick.all.each do |brick|
  puts brick.id
  puts brick.name
  puts brick.description
  puts brick.color_id
end
----

[source,bash]
----
$ bundle exec ruby script.rb
# All colors
57
Black
58
yellow
# All Bricks
47
Awesome brick
This brick is awesome
57
----
