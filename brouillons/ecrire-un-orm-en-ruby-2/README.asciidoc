= Écrire un ORM en Ruby partie 2{nbsp}: récupération des champs, insertion et sélection
Julien Kirch
v0.1, 2020-05-10
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

Ceci est le deuxième article d'une série de quatre décrivant pas à pas comment écrire un ORM SQL minimal en Ruby.

Après link:../ecrire-un-orm-en-ruby-1/[le premier article] où j'ai posé les bases de l'outil, je vais ici ajouter ce qu'il manque pour faire les premières requètes.

== Des modèles avec des champs

La première étape va s'intéresser aux champs des modèles.

Il serait possible de les paramétrer via le fichier de configuration de schema `schema.rb`, mais je vais plutôt utiliser les métadonnées de la base de données, car c'est une bonne occasion de donner un aperçu de leur fonctionnement.

En effet même si tous les ORMs n'utilisent pas les métadonnées beaucoup le font, et comprendre que cela n'est pas si compliquée est bien utile.

Même si cela ne fait pas partie du standard SQL, la majorités des bases de données de ce type fournissent des requéter les métadonnées des bases telles que les tables, les index{nbsp}…

Suivant les systèmes on pourra utiliser du SQL&#8201;—{nbsp}en intérrogeant des tables particulières{nbsp}—&#8201;ou des commandes spécifiques.

Avec SQLite, l'accès aux métadonnées se fait via des link:https://www.sqlite.org/pragma.html[la commandes PRAGMA].


[source]
----
$ sqlite3 orm-ruby.sqlite
sqlite> .header on -- Active l'affichage des noms de colonnes dans les requêtes
sqlite> pragma table_info('color'); -- Donne des informations sur la table `color`

cid|name|type|notnull|dflt_value|pk
0|id|INTEGER|1||1
1|name|TEXT|1||0
----

Pour chaque colonne `table_info` nous donne son identifiant, son nom, son type, si elle est nullable, son éventuelle valeur par défaut, et si il s'agit de la clé primaire de la table.

Avec la gem sqlite3, la méthode `SQLite3::Database#table_info` fait l'appel la pragma et renvoie le résultat sous une forme accessible.

Pour ajouter les colonnes disponibles dans chaque table, commençons par définir une classe `ColumnDefinition` qui contiendra les informations qui nous intéressent, à savoir le nom et le type de la colonne.

.generator.rb
[source,ruby]
----
class ColumnDefinition

  attr_reader :name, :type

  # @param [String] name
  # @param [String] type
  def initialize(name, type)
    @name = name
    @type = type
  end

end
----

Ensuite, je dois récupérer les colonnes de chaque table.
L'endroit le plus simple est de le faire juste avant de créer les classes de modèles, alors qu'on est déjà en train d'itérer sur chaque modèle, on pourra alors passer la liste des colonnes au template.

Mais pour commencer, il faut se connecter à la base de donnée.
Je vais utiliser une base en local avec un fichier stocké dans le répertoire du projet

.generator.rb
[source,ruby]
----
DATABASE = SQLite3::Database.new('orm-ruby.sqlite')
----

puis{nbsp}:

.generator.rb
[source,ruby]
----
models_code = ModelDefinition::MODELS_DEFINITIONS.map do |model|
  # List the columns definitions
  columns_definitions = DATABASE.table_info(model.table_name).collect do |column_info|
    column_name = column_info['name']
    column_type = column_info['type']
    ColumnDefinition.new(column_name, column_type)
  end
  erb.result_with_hash(model: model, columns_definitions: columns_definitions)
end
----

Dans le template, `columns_definitions` contient alors la liste des `ColumnDefinition` prêt à l'emploi.

Presque prêt à l'emploi car il reste une subtilité{nbsp}: `table_info` renvoie les types SQL des colonnes (ou plus précisément le type SQLite) comme `TEXT`, pour pouvoir l'utiliser dans le code je dois le transformer en types Ruby comme `String`.

Pour se faire, nous allons utiliser une `Hash` pour faire la conversion entre les deux.

.generator.rb
[source,ruby]
----
SQLITE_TYPE_TO_RUBY_CLASS = {
    'INTEGER' => 'Integer',
    'TEXT' => 'String'
}
----

Elle ne contient que les types que l'on va rencontrer dans notre exemple, il sera ensuite possible de l'enrichir en fonction des besoins.

En modifiant le code pour utiliser `SQLITE_TYPE_TO_RUBY_CLASS`, cela donne :

.generator.rb
[source,ruby]
----
models_code = ModelDefinition::MODELS_DEFINITIONS.map do |model|
  # List the columns definitions
  columns_definitions = DATABASE.table_info(model.table_name).collect do |column_info|
    column_name = column_info['name']
    sql_type = column_info['type']
    ruby_type = SQLITE_TYPE_TO_RUBY_CLASS[sql_type]
    ColumnDefinition.new(column_name, ruby_type)
  end
  erb.result_with_hash(model: model, columns_definitions: columns_definitions)
end
----

Avec le nom et le type de chaque colonne, je vais pouvoir générer les getter et les setters en itérant sur les `ColumnDefinition` dans le template{nbsp}:

.models.erb.rb
[source]
----
class <%= model.name %>

  <% columns_definitions.each do |column_definition| %>
  <% column_name = column_definition.name %>
  <% column_type = column_definition.type %>
  # @return [<%= column_type %>]
  def <%= column_name %>
    @<%= column_name %>
  end

  # @param [<%= column_type%>] <%= column_name %>
  # @return [void]
  def <%= column_name %>=(<%= column_name %>)
    @<%= column_name %> = <%= column_name %>
  end
  <% end %>

end
----

Ce qui donne ce résultat{nbsp}:

.models.rb
[source,ruby]
----
class 

  # @return [Integer]
  def id
    @id
  end

  # @param [Integer] id
  # @return [void]
  def id=(id)
    @id = id
  end
  
  # @return [String]
  def name
    @name
  end

  # @param [String] name
  # @return [void]
  def name=(name)
    @name = name
  end
end
# …
----

Ce qui permet d'écrire{nbsp}:

[source,ruby]
----
require_relative 'models'

black = Color.new
black.name = 'Black'
----

On peut voir ici l'intérêt de la génération de code à froid{nbsp}: on peut facilement consulter les méthodes disponibles avec leurs informations de type.
Avec un IDE on peut même disposer de l'autocompletion.

Je ne l'utilise pas dans mon exemple, mais l'information de nullabilité des colonnes peut servir pour renseigner la nullabilité des paramètres ou des retours des méthodes.

== L'insertion

Une fois qu'on a la liste des champs et qu'il est possible de leur attribuer des valeurs, il est temps de pouvoir insérer ces données dans la base.

Pour cela il faut générer ce type de requêtes{nbsp}:

[source,sql]
----
INSERT INTO table_name
  (column_name_1, column_name_2, …)
  values (column_value_1, column_value_2, …)
----

Pour partager le code entre les modèles, je vais ajouter une classe `Model` qui sera parente des classes de modèles.

.model.rb
[source,ruby]
----
# @abstract
class Model
end
----

Je la marque comme abstraite avec `@abstract` pour indiquer qu'elle n'est pas utilisable directement mais qu'on doit passer par les classes dérivées.

Pour générer les requêtes d'insertion, je vais avoir besoin du nom de la table et de la liste des colonnes de chaque modèle.
Pour cela je vais ajouter des méthodes de classes pour récupérer les valeurs.

Je les déclare dans la classe parente{nbsp}:

.model.rb
[source,ruby]
----
# @abstract
class Model

  # Method should be implemented in subclasses
  # @abstract
  # @return [String]
  def self.table_name
    raise NotImplementedError
  end

  # Method should be implemented in subclasses
  # @abstract
  # @return [Array<String>]
  def self.columns
    raise NotImplementedError
  end
end
----

Puis je les ajoute au template de modèle, avec la déclaration de l'héritage{nbsp}:


.models.erb.rb
[source]
----
class <%= model.name %> < Model
  # @return [String]
  def self.table_name
      '<%= model.table_name %>'
  end

  # @return [Array<String>]
  def self.columns
      <%= columns_definitions.map do |column_definition|
        column_definition.name
      end %>
  end
end
----

Ce qui donne, en relançant la génération{nbsp}:

.models.rb
[source,ruby]
----
class Color < Model

  # @return [String]
  def self.table_name
      'color'
  end

  # @return [Array<String>]
  def self.columns
      ["id", "name"]
  end

  # …
end
----

Avec ces méthodes je peux générer la requête, en ajoutant une connection à la base pour pouvoir l'exécuter.

Pour la requête je vais utiliser la méthode `SQLite3::Database#execute`, qui permet de passer les valeurs des colonnes en paramètre plutôt que de les mettre dans le corps de la requête, ce qui donnera ce genre d'appel{nbsp}:

[source,ruby]
----
DATABASE.execute('INSERT INTO color (name) values (?)', ['Black'])
----

Cette syntaxe permet d'éviter d'avoir à se préocuper du format à utiliser pour passer les valeurs à la base, et donc d'éviter des risque de sécurité.

Dans notre case les valeurs de l'`id` des modèles ne doivent pas être insérée car elles sont gérées par la base, c'est pour cela que les colonnes `id` sont déclarées en `AUTOINCREMENT`.
Cela simplifie le code et fournit une garantie d'unicité dans le cas d'une base SQL standard.

La manière de s'y prendre n'est pas standardisé et dépend donc de la base de données.
Il y a deux grandes approches{nbsp}: soit les valeurs sont retournées par la requête d'insertion, ou une requête spécifique permet de récupérer les `id` des valeurs qu'on vient d'insérer.

SQLite utilise la deuxième solution via link:https://www.sqlite.org/lang_corefunc.html#last_insert_rowid[`last_insert_rowid()`].

.model.rb
[source,ruby]
----
require 'sqlite3'

# @abstract
class Model

  # We need a connection to the dabatase
  DATABASE = SQLite3::Database.new('orm-ruby.sqlite')

  # @return [void]
  def insert
    # Columns names without the 'id' column
    # because the id values are managed by the database
    columns_names_except_id = self.class.columns.
        select { |column| column != 'id' }

    # Quote the columns names to avoid escaping issues
    quoted_columns_names_except_id = columns_names_except_id.
        map { |column_name| SQLite3::Database.quote(column_name) }

    # Columns vales without 'id'
    columns_values_except_id = columns_names_except_id.
        map { |column_name| self.send(column_name) }

    # Query looks like
    # INSERT INTO table_name
    #   (column_name_1, column_name_2, …)
    #   VALUES (?, ?, …)
    DATABASE.execute(
        "INSERT INTO #{SQLite3::Database.quote(self.class.table_name)} " +
            "(#{quoted_columns_names_except_id.join(', ')}) " +
            "VALUES (#{Array.new(columns_names_except_id.length, '?').join(', ')})",
        columns_values_except_id
    )

    # Set the `id` of the model from the value provided by the database
    self.id = DATABASE.last_insert_row_id
  end
end
----

Les méthodes `table_name` et `columns` étant implémentées dans chaque classe de modèle, utiliser `self.class.table_name` et `self.class.columns` dans la classe parente `Model` appellera bien la méthode spécifique de chaque modèle plutôt que les méthodes de la classe `Model`.

Avec ce code, on peut enfin insérer les données{nbsp}:

.script.rb
[source,ruby]
----
require_relative 'model'
require_relative 'models'

black = Color.new
black.name = 'Black'
black.insert

brick = Brick.new
brick.color_id = black.id
brick.name = 'Awesome brick'
brick.description = 'This brick is awesome'
brick.insert
----

On peut vérifier dans la base que tout s'est bien passé{nbsp}:

[source,bash]
----
$bundle exec ruby script.rb
$ sqlite3 orm-ruby.sqlite

sqlite> select * from color;

1|Black

sqlite> select * from brick;

1|Awesome brick|This brick is awesome|1
----

.model.rb
[source,ruby]
----
class Model
  # @return [Array]
  def self.all
    quoted_columns_names = columns.
        map { |column_name| SQLite3::Database.quote(column_name) }

    # Query looks like
    # SELECT column_name_1, column_name_2, …
    #   FROM 'table_name'
    DATABASE.execute(
        "SELECT #{quoted_columns_names.join(', ')} " +
            "FROM #{SQLite3::Database.quote(table_name)}"
    ).map do |result_row|
      model_instance = self.new
      columns.each_with_index do |column, column_index|
        model_instance.send("#{column}=", result_row[column_index])
      end
      model_instance
    end
  end
end
----

.model.rb
[source,ruby]
----
class Model
  # @return [void]
  def self.truncate
    DATABASE.execute("DELETE FROM #{SQLite3::Database.quote(table_name)}")
  end
end
----

.script.rb
[source,ruby]
----
require_relative 'model'
require_relative 'models'

Brick.truncate
Color.truncate

black = Color.new
black.name = 'Black'
black.insert

yellow = Color.new
yellow.name = 'Yellow'
yellow.insert

brick = Brick.new
brick.color_id = black.id
brick.name = 'Awesome brick'
brick.description = 'This brick is awesome'
brick.insert

puts '# All colors'
Color.all.each do |color|
  puts color.id
  puts color.name
end

puts '# All Bricks'
Brick.all.each do |brick|
  puts brick.id
  puts brick.name
  puts brick.description
  puts brick.color_id
end
----

[source,bash]
----
$ bundle exec ruby script.rb
# All colors
57
Black
58
yellow
# All Bricks
47
Awesome brick
This brick is awesome
57
----
