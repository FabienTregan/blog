[#baba-is-you-3]
ifeval::["{doctype}" == "book"]
= Part 3: finding a solution to the first level
endif::[]
ifeval::["{doctype}" != "book"]
= Writing a "`Baba Is You`" solver, part 3: finding a solution to the first level
endif::[]
:author: Julien Kirch
:revnumber: v0.1
:docdate: 2019-05-09
:article_lang: en
:ignore_files: direction1.java, graph1.asciidoc, graph1.mmd, graph1.png, level1.java, log1.txt, state1.java, state2.java, state3.java, stateavailablemovementstest1.java, statetrytogotest1.java, statetrytogotest2.java
:article_image: first-level1.png
ifndef::source-highlighter[]
:source-highlighter: pygments
:pygments-style: friendly
endif::[]
:article_description: At the end it should works
:figure-caption!:

ifeval::["{doctype}" == "book"]
Following the second part,
endif::[]
ifeval::["{doctype}" != "book"]
Following link:../baba-is-you-2/[the second part],
endif::[]
I'll deal with the logic to find a solution to the first level.

image::../baba-is-you-3/first-level1.png[title="Here it is",align="center",width=293,height=342]

The first level has a feature that will make things much simpler:
the rules can't be changed.

This means that fixed rules can be enough to solve this level,
and that the "`changing rules`" feature can be dealt with later.

== First the algo

I'll first try to find a valid solution with a simplified algo that don't cover all possible cases, then I'll update it to make it compliant with the game rules.

I'll do it this way because the update will add complexity to the behaviors, and I prefer to first reach a state where I solved something.

Each turn the solver considers a game state, from it there is _at most_ four possible moves: going up, down, right or left.

At most because some of the directions can be blocked by an object or by the border of the level's board.

If you can go in a direction, you may reach a winning state, in this case the the solver stops.

If you don't solve the level, you can add this new state to the list, and go on with the main loop.

There's a catch: Baba is not a "`burning bridge`" game where you can't move back.
Before checking if a new state is interesting, it must be vetted against the previously met cases to avoid doing the same thing again and again.

image::../baba-is-you-3/move1.png[title="Starting",align="center",width=554,height=260]

image::../baba-is-you-3/move2.png[title="Moving",align="center",width=552,height=264]

image::../baba-is-you-3/move3.png[title="And going back",align="center",width=556,height=266]

If it's not done Baba could go left, then right, then left, then left…
and a significant portion of the solving time would be waster to deal with cases that has already been dealt with.

include::graph1.asciidoc[]

== Then some code

First thing is to detect if a move is possible.

In the further levels of the game, "`you`" can be several items, but in the first level you only control Baba, so first let's find Baba.

To be able to go in a direction only requires to test if Baba can go in this direction.

First I check if Baba can physically go in this direction from the level point of view.

It requires to be able to specify a direction.

.Direction.java
[source,java]
----
include::direction1.java[]
----

Then the code:

.State.java
[source,java]
----
include::state1.java[]
----

And testing it:

.StateAvailableMovementsTest.java
[source,java]
----
include::stateavailablemovementstest1.java[]
----

Then it's time to deal with the content.
The behavior depends of the content of the position Baba wants to move to.
The code must do three things: test if the movement is valid, test if the new position is a winning one, and calculate the new board position.

It would be possible to write each step in separate pass but I find it easier to do it in one time because all three steps depends mostly of the kind of elements on the target cell.

Calculating a new board position is done by cloning the existing one and updating the values that need to be updated.

Pushing a rock is more complex case than the others, so I'll ignore it first:

.State.java
[source,java]
----
include::state2.java[]
----

And testing it:

.StateTryToGoTest.java
[source,java]
----
include::statetrytogotest1.java[]
----

== A solution

When moving a rock, the simplest case is to check if 

* the rock is not against a border of the level
* there is nothing behind it

In this case Baba can go in this direction and push the rock.

image::../baba-is-you-3/rock1.png[align="center",width=556,height=274]

image::../baba-is-you-3/rock2.png[align="center",width=566,height=268]


.State.java
[source,java]
----
include::state3.java[]
----

.StateTryToGoTest.java
[source,java]
----
include::statetrytogotest2.java[]
----

If the program now, it will run indefinitely.
Not because of a bug but because of a missing feature:
it lacks the ability to remember that a state has already been visited, thus doing the same thing again and again.

Java makes it a bit more complicated than it should do:

.Level.java
[source,java]
----
include::level1.java[]
----

And… it works, the program can solve the level:

[source]
----
include::log1.txt[]
----

\o/

In the next part I'll have a look on the solution that has been found.