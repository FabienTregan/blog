= HTTP, _mechanical sympathy_ et _leaky abstraction_
Julien Kirch; Fabien Lamarque
v0.1, 2019-06-03
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

Plan que j'ai en tête pour un talk rapide :

. Qu'est-ce qu'une leaky abstraction, leaky encapsulation ?
. Qu'est-ce que la mechanical sympathy, des exemples
. Pourquoi l'encapsulation d'un appel HTTP dans un service comme dans l'exemple en
dessous pose problème
. Une idée/proposition de modélisation qui est enrichi de "mechanical sympathy"

Lorsqu'un développeur Java décide d'encapsuler un appel HTTP, il passe souvent par un service

[source,java]
----
private Entity getContent (String code, String referentielUrl) {
   HttpHeaders headers = new HttpHeaders();
   headers.setContentType(MediaType.APPLICATION_JSON);
   HttpEntity<Entity> httpEntity = new HttpEntity<>(headers);
   ResponseEntity<Entity> responseEntity = restTemplate.exchange(
           referentielUrl,
           HttpMethod.GET, httpEntity, Entity.class, code);

   return responseEntity.getBody();
}
----


Cette méthode est correcte, fait un appel http à une API REST, et retourne un objet 
`Entity` récupéré.
L'avantage de cette méthode est qu'elle crée donc une abstraction de l'appel HTTP. C'est à dire qu'elle cache toutes ces logiques
d'URL, de verbe HTTP, de protocole et de désérialization derrière une méthode plus facilement utilisable, avec une interface plus simple.
