= HTTP, _mechanical sympathy_ et _leaky abstraction_
Julien Kirch; Fabien Lamarque
v0.1, 2019-06-03
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

== Qu'est-ce qu'une abstraction{nbsp}?

Dans cet article, une abstraction correspond au fait d'exposer une API au dessus d'une fonctionnalité d'une manière qui n'expose pas toute la complexité interne de la fonctionnalité, mais au contraire qui met à disposition une version simplifiée.

Par exemple certaines API proposées pour écrire des fichiers masquent les questions de cache, de gestion des erreurs, de spécificité de chaque système de fichier{nbso}…

En fonctions des situations, il y a plusieurs raisons d'utiliser des abstractions, raisons qui se combinent souvent, par exemple{nbsp}:

* Rendre plus simple l'utilisation de la fonctionnalité{nbsp};
* Permettre de modifier l'implémentation de la fonctionnalité sans que cela n'ait de conséquences sur les outils qui utilisent l'API{nbsp};
* Pouvoir avoir plusieurs implémentations différentes et permettre de passer de l'une à l'autre sans conséquences sur les outils qui utilisent l'API{nbsp};
* …

Les abstractions sont immensément utiles.

Imaginez si les applications web avaient besoin d'avoir connaissance du fait que la machine sur laquelle elles fonctionnent utilise des disques magnétique ou des SSD.
Cela signifierait d'avoir à coder (et à tester) les deux situations, que pour ajouter un disque SSD il faudrait valider la compatibilité des applications{nbsp}…

== Qu'est-ce qu'une leaky abstraction{nbsp}?

Parfois les abstractions ont des défauts.
C'est par exemple le cas des "`leaky abstraction`", ou link:https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/[abstractions qui fuient].

Une abstractions qui fuit est une abstraction dont certaines parties du fonctionnement interne qui sont supposés être masquées aux outils sont quand même visible d'une manière ou d'une autre.

Par exemple une abstraction permettant de manière transparente d'appeler un service local ou distant n'aura peut-être pas les mêmes performances ou les mêmes erreurs suivant les cas.

Si une personne développe avec une implémentation locale, elle pourra avoir des mauvaises surprise si le déploiement en production se fait sur une implémentation distante.

La fuite peut se faire au niveau de l'API (par exemple des paramètres subtilement différents), ou du fonctionnement, car la performance ou la fiabilité ne font pas partie de l'API.


== Qu'est-ce que la mechanical sympathy, des exemples

Parfois briser l'encapsulation est une bonne chose

== Leaky ou sympathy

Discussion sur le fait que la différence c'est de subir ou pas la désencapsulation

Quand on designe une API, on peut faire le choix de permettre de supprimer une couche (et ça a des conséquences), mais leaky c'est un problème

== Pourquoi l'encapsulation d'un appel HTTP dans un service comme dans l'exemple en
dessous pose problème

== Une idée/proposition de modélisation qui est enrichi de "mechanical sympathy"

''''

Lorsqu'une personne qui développe en Java décide d'encapsuler un appel HTTP, il passe souvent par un service

[source,java]
----
private Entity getContent (String code, String referentielUrl) {
   HttpHeaders headers = new HttpHeaders();
   headers.setContentType(MediaType.APPLICATION_JSON);
   HttpEntity<Entity> httpEntity = new HttpEntity<>(headers);
   ResponseEntity<Entity> responseEntity = restTemplate.exchange(
           referentielUrl,
           HttpMethod.GET, httpEntity, Entity.class, code);

   return responseEntity.getBody();
}
----


Cette méthode est correcte, fait un appel http à une API REST, et retourne un objet 
`Entity` récupéré.
L'avantage de cette méthode est qu'elle crée donc une abstraction de l'appel HTTP. C'est à dire qu'elle cache toutes ces logiques
d'URL, de verbe HTTP, de protocole et de désérialization derrière une méthode plus facilement utilisable, avec une interface plus simple.
