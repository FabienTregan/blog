= HTTP, _mechanical sympathy_ et _leaky abstraction_
Julien Kirch; Fabien Lamarque
v0.1, 2019-06-03
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

== Les abstractions

=== Qu'est-ce qu'une abstraction ?

Dans cet article, une abstraction correspond au fait d'exposer une API au dessus d'une fonctionnalité d'une manière qui n'expose pas toute la complexité interne de la fonctionnalité, mais au contraire qui met à disposition une version simplifiée.

Par exemple certaines API proposées pour écrire des fichiers masquent les questions de cache, de gestion des erreurs, de spécificité de chaque système de fichier{nbso}…

En fonctions des situations, il y a plusieurs raisons d'utiliser des abstractions, raisons qui se combinent souvent, par exemple :

* Rendre plus simple l'utilisation de la fonctionnalité ;
* Permettre de modifier l'implémentation de la fonctionnalité sans que cela n'ait de conséquences sur les outils qui utilisent l'API ;
* Pouvoir avoir plusieurs implémentations différentes et permettre de passer de l'une à l'autre sans conséquences sur les outils qui utilisent l'API ;
* …

Les abstractions sont immensément utiles.

Imaginez si les applications web avaient besoin d'avoir connaissance du fait que la machine sur laquelle elles fonctionnent utilise des disques magnétique ou des SSD.
Cela signifierait d'avoir à coder (et à tester) les deux situations, que pour ajouter un disque SSD il faudrait valider la compatibilité des applications …

=== Quand les abstractions ont des fuites

Parfois les abstractions ont des défauts.

C'est par exemple le cas des "`leaky abstraction`", ou link:https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/[abstractions qui ont des fuites].

Une abstractions qui fuit est une abstraction dont certaines parties du fonctionnement interne qui sont supposés être masquées aux outils sont quand même visible d'une manière ou d'une autre.
Dans ce cas le fonctionnement interne fuit à travers l'abstraction qui est sensé le garder à l'intérieur, comme l'eau à travers le trou d'un tuyau.

Par exemple une abstraction permettant de manière transparente d'appeler un service local ou distant n'aura peut-être pas les mêmes performances ou les mêmes cas d'erreur dans les cas.

Si une personne développe avec une implémentation locale, elle pourra avoir des mauvaises surprise si le déploiement en production se fait sur une implémentation distante.
Il lui faudra alors peut-être adapter son code pour prendre en compte les deux possibilité (gérer les différents cas d'erreur, ou implémenter des comportements différents si la différence de performance est suffisamment importante).

=== Fuite ou pas fuite ?

Déterminer si quelque chose est une fuite dans une abstraction n'est pas toujours facile.

Par exemple dans le cas d'une bibliothèque permettant des appels locaux ou distants, la différence de performance est prévisible.

Fournir une même syntaxe d'appel dans les deux cas ne signifie pas qu'ils vont avoir les mêmes performances.
C'est la personne qui développe qui fait peut-être l'hypothèse "`si la syntaxe est identique cela veut probablement dire que la performance l'est aussi`".

Cela signifie qu'il n'y a pas de tromperie de la part de l'outil, mais seulement une mauvaise interprétation de la part de la personne.
Le problème n'est pas forcément l'abstraction fournie par l'outil, mais le modèle mental de l'abstraction faite par la personne.

Dans le cas d'un outil dont la fonction principale est de masquer le fait que des appels soient locaux ou distants, il pourrait être pertinent que l'outil précise explicitement que les performances ne sont pas les mêmes dans les deux cas, car la mauvaise interprétation est prévisible.

=== Une abstraction ça va …

Mais quand plusieurs abstractions sont empilées, cela devient plus compliqué.
Par exemple si vous utilisez un outil d'édition de texte avec un système de fichier distants, comme un partage de fichier windows, les performances seront peut-être dégradées, et vous aurez peut-être des erreurs -- comme des erreurs de déconnexions réseau -- auxquelles vous ne vous attendiez pas de la part d'un éditeur de texte, car votre modèle mental d'un éditeur de texte est celui d'une éditions de fichier locale.

L'outil d'édition ne texte ne sait rien de l'endroit d'où viennent les fichiers : il s'agit d'une abstraction fournie par le système d'exploitation.
Il est même possible que les personnes qui développent l'outil ne l'aient jamais utilisé ou testé dans cette situation.

L'outil est peut-être même sorti avant que ce système de partage de fichier n'existe. C'est par exemple le cas lorsque [.line-through]#Google Doc# [.line-through]#Google Drive# Google One change son implémentation de synchronization : du jour au lendemain vos outils utiliseront le nouveau système sans avoir pu être testé auparavant.

Par rapport à l'outil précédent, il paraîtrait plus étrange de demander à la documentation de l'éditeur de texte de préciser ces comportements spécifiques.

=== Multiplier les couches et les risques

Les abstractions sont immensément utiles : ce sont elles qui permettent de faire en sorte qu'un système composé de multiples composants au reste raisonnablement utilisable.

Le revers de la médaille c'est que lorsqu'une abstraction fuite et que cela cause un problème, résoudre le problème peut nécessiter d'avoir à comprendre le fonctionnement interne de l'abstraction, alors que jusque là on n'avait pas à s'en préoccuper.

Un peu paradoxalement, plus une abstraction est efficace et mieux elle masque les choses, plus le risque que cette situation apparaisse.

Plus un système est complexe, plus il y a le risque qu'une interaction entre deux briques aboutisse à cette situation, avec en plus le fait qu'avant de pouvoir corriger le problème il faut commencer par identifier où il se trouve.

C'est un risque important dans les systèmes modulaires donc les composants peuvent varier (comme un système Linux), face aux systèmes conçus d'un seul tenant (comme les systèmes d'exploitation embarqués).

== La mechanical sympathy

=== Qu'est-ce que la mechanical sympathy ?

L'un des objectif d'un système basé sur des abstractions est souvent d'éviter aux personnes qui l'utilisent d'avoir à comprendre son fonctionnement interne pour pouvoir l'utiliser.

Il arrive qu'un problème de conception ou de mise en œuvre du modèle fasse fuiter l'abstraction, et on est alors obligé de comprendre les rouages internes pour s'en servir.

Mais il peut aussi arriver qu'on ait envie de comprendre un système, même si l'abstraction qu'il propose fonctionne de manière satisfaisante, et c'est ce qu'on appelle _mechanical sympathy_ ou sympathie pour la mécanique.

[quote, Jackie Stewart, pilote de course]
____
Vous n'avez pas besoin d'être ingénieur·e pour être pilote de course, mais vous avez besoin d'avoir de la sympathie pour la mécanique.
____

L'idée de la sympathie pour la mécanique est que pour utiliser _efficacement_ un système, il peut être préférable de comprendre ce qui se passe sous le capot.

Efficacement peut signifier atteindre un certain niveau de performance, mais peut aussi vouloir dire pouvoir rapidement diagnostiquer des problèmes ou expliquer certains comportements.

=== Mechanical sympathy et respect du modèle

Ce n'est pas parce qu'on comprend le fonctionnement qu'on va briser l'encapsulation et se mettre à triturer partout.

Parce briser les encapsulation rend les systèmes plus compliqués à comprendre et à maintenir.
Au contraire, avec la mechanical sympathy, mieux tu comprends la complexité sous-jacente du système mieux tu comprends la valeur à avoir des modules bien isolé.

Mieux comprendre ça peut aussi permettre de mieux utiliser l'abstraction pour ne pas avoir à la contourner. Exemple avec un ORM

QQQ

=== Leaky ou sympathy

Discussion sur le fait que la différence c'est de subir ou pas la 
=== Pourquoi l'encapsulation d'un appel HTTP dans un service comme dans l'exemple en
dessous pose problème

=== Une idée/proposition de modélisation qui est enrichi de "mechanical sympathy"

''''

Lorsqu'une personne qui développe en Java décide d'encapsuler un appel HTTP, il passe souvent par un service

[source,java]
----
private Entity getContent (String code, String referentielUrl) {
   HttpHeaders headers = new HttpHeaders();
   headers.setContentType(MediaType.APPLICATION_JSON);
   HttpEntity<Entity> httpEntity = new HttpEntity<>(headers);
   ResponseEntity<Entity> responseEntity = restTemplate.exchange(
           referentielUrl,
           HttpMethod.GET, httpEntity, Entity.class, code);

   return responseEntity.getBody();
}
----


Cette méthode est correcte, fait un appel http à une API REST, et retourne un objet 
`Entity` récupéré.
L'avantage de cette méthode est qu'elle crée donc une abstraction de l'appel HTTP. C'est à dire qu'elle cache toutes ces logiques
d'URL, de verbe HTTP, de protocole et de désérialization derrière une méthode plus facilement utilisable, avec une interface plus simple.
