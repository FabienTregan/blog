= HTTP, _mechanical sympathy_ et _leaky abstraction_
Julien Kirch; Fabien Lamarque
v0.1, 2019-06-03
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

== Qu'est-ce qu'une abstraction

== Qu'est-ce qu'une leaky abstraction, leaky encapsulation ?

Briser l'encapsulation à bon escient

== Qu'est-ce que la mechanical sympathy, des exemples

Parfois briser l'encapsulation est une bonne chose

== Leaky ou sympathy

Discussion sur le fait que la différence c'est de subir ou pas la désencapsulation

Quand on designe une API, on peut faire le choix de permettre de supprimer une couche (et ça a des conséquences), mais leaky c'est un problème

== Pourquoi l'encapsulation d'un appel HTTP dans un service comme dans l'exemple en
dessous pose problème

== Une idée/proposition de modélisation qui est enrichi de "mechanical sympathy"

''''

Lorsqu'une personne qui développe en Java décide d'encapsuler un appel HTTP, il passe souvent par un service

[source,java]
----
private Entity getContent (String code, String referentielUrl) {
   HttpHeaders headers = new HttpHeaders();
   headers.setContentType(MediaType.APPLICATION_JSON);
   HttpEntity<Entity> httpEntity = new HttpEntity<>(headers);
   ResponseEntity<Entity> responseEntity = restTemplate.exchange(
           referentielUrl,
           HttpMethod.GET, httpEntity, Entity.class, code);

   return responseEntity.getBody();
}
----


Cette méthode est correcte, fait un appel http à une API REST, et retourne un objet 
`Entity` récupéré.
L'avantage de cette méthode est qu'elle crée donc une abstraction de l'appel HTTP. C'est à dire qu'elle cache toutes ces logiques
d'URL, de verbe HTTP, de protocole et de désérialization derrière une méthode plus facilement utilisable, avec une interface plus simple.
