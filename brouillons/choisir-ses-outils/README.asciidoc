= Bien choisir ses outils
Julien Kirch
v0.1, 2020-06-17
:article_lang: fr
:article_image: tools.png

Je formalise ici un certain nombres d'idées sur les choix d'outils.

== Le maintien en condition opérationnelle

Dans les grandes organisations pour lesquelles j'ai travaillé j'ai souvent croisé le terme de "`Maintien en condition opérationnelle`" ou MCO.

Pour un outil, le MCO c'est le fait de maintenir un fonctionnement satisfaisant, hors des évolutions qu'on lui fait subir.

Pour un logiciel, cela correspond au fait de corriger des bugs et de faire les mises à jour d'outils permettant de bénéficier de mises à jour de sécurité.

== Le prix de la MCO

Si on parle beaucoup des problèmes pour développer de nouveaux logiciels, et que certains produits continuent à évoluer tout au long de leur vie, il n'en restent pas moins que pour d'autres la phase de développement actif est suivi d'une phase de maintenance, où les évolutions se font de-ci de-là, avec parfois des périodes longues entre chacune d'entre-elles.

Quand un logiciel utilise des outils qui évoluent rapidement, cela peut signifier que même sans avoir à développer de nouvelles fonctionnalités du temps doit être dépensé régulièrement pour le maintenir en l'état.

À l'inverse, s'appuyer sur des outils stables et pérennes permet de limiter ce temps.

On peut se moquer de ce genre d'outils pour ne pas être toujours au goût du jour, par exemple Java, Debian ou même RedHat, mais pour des logiciels qui sont destinés à durer, s'appuyer sur ce type d'infrastructure peut faire une différence importante sur le montant de la facture chaque année.

== Si une dépendance s'arrête{nbsp}?

Si des dépendances peuvent évoluer, et donc demander des adaptations régulières, d'autres peuvent s'arrêter, par exemple parce qu'un projet open source n'a plus personne pour le maintenir.

Si le code en question n'est pas exposé à l'extérieur et que ses propres dépendances sont stables cela peut avoir peu ou pas de conséquences.
Cela peut même être une bonne nouvelle car si des mises à jours ne sont plus publiées cela signifie qu'il n'est plus nécessaire de les intégrer.

Dans le cas contraire cela signifie généralement des arbitrages compliqués{nbsp}: faut-il accepter le risque de faille de sécurité non corrigées, monter en compétence sur l'outil pour internaliser sa maintenance, se décider à migrer sur un autre outil…{nbsp}?

== Comment décider{nbsp}?

Il n'y a pas de formule simple, car comme disait Yogi Berra "`Faire des prévisions est difficiles, et encore plus quand elles concernent le futur`".

link:https://hal.archives-ouvertes.fr/hal-02117588/document[Cet article] propose une approche intéressante qui prend en compte la durée de vie du projet par rapport à la stabilité des dépendances.

Sauf que bien entendu il peut-être assez difficile de prévoir la durée de vie d'un projet, sachant qu'elle peut dépendre elle-même du niveau de sa MCO, car plus un projet coûte cher ou plus il pose de risque plus l'incitation à le décomissionner est forte.

Si être pessimiste permet de limiter les risques, cela limite aussi ce qu'il est possible de faire si les solutions qui ont le plus de fonctionalités ne sont pas encore stabilisées, comme certains frameworks JavaScript actuels.

Pour les projets plutôt gros, il peut être intéressant de faire des choix différents en fonction des parties, par exemple d'avoir des solutions pérènnes pour la partie serveur qui devrait vivre plus longtemps, et des choix plus libres sur la partie front.
Dans ce cas on rend le système un peu plus complexe en échange de plus de liberté technologique.

À l'inverse, une solution qui peut être tentante mais qui n'en vaut souvent pas la peine et d'ajouter une couche d'indirection entre le code métier et le code du framework.
Dans mon expérience, la couche d'indirection ainsi obtenue ajoute du travail sans généralement apporter le découplage qu'on espére{nbsp}: les changements de frameworks s'accompagnent le plus souvent d'un changement d'API, et il est rare qu'une couche d'indirection développée ainsi soit en mesure de compenser proprement ces modifications d'API.

== Frameworks internes et externes

On trouve des mouvements comme celui du link:https://www.frameworklessmovement.org[frameworkless movement] qui propose de ne pas du tout utiliser de frameworks externes, ou au moins de limiter drastiquement leur usage.
Si la question du risque qu'ils posent est légitime, le fait de vouloir trop redévelopper de choses en interne pose d'autre risques, signifie assumer seul la charge de maintenance, 


== Les projets personnels

Sur les projets personnels le MCO peut vraiment être usant.
Par exemple sur un projet sur lequel vous vous remettez de temps en temps pour explorer une idée, si à chaque fois que vous ouvrez votre code vous devez passer du temps à mettre à jour les dépendances et à comprendre pourquoi quelque chose s'est cassé, vous risquez de vous démotiver et de vous arrêter.

== Quand la MCO ne compte pas
