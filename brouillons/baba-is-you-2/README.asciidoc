= Writing a "`Baba Is You`" solver, part 2: the first level
Julien Kirch
v0.1, 2019-05-05
:article_lang: en
:ignore_files: 
:article_image: first-level.png
:source-highlighter: pygments
:pygments-style: friendly

Following link:../babis-you-1/[the first part], we'll work on solving the first level.

image::first-level.png[title="Here it is"]

The first level has a feature that will simplify things:
the rules can't be changed.

This means that fixed rules can be enough to solve this level, and that the changing rules thingie can be dealt with later.

image::graph.svg[width=731,height=513]

== First the plumbing

Before dealing with the solving logic, some plumbing is required to establish the game loop.

Most of the code shown here is ported from my previous link:https://github.com/archiloque/rgbexpress[efforts].

First the `Level` class will contain data related to a game level, at first only the information we found in the level, then -- by experience -- we'll add other data that will make the calculations simpler and/or faster.

.Level.java
[source,java]
----
include::level1.java[]
----

Then the `State` will represent a state of the game being solved.
It will follow the same path as the `Level`: it starts as a small class with few attributes (the current status of the game and a pointer to the `Level`) and becomes larger as we add features.

.State.java
[source,java]
----
include::state1.java[]
----

To manage the list of states several possibilities are available, like using a link:https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)[FIFO queue] for link:https://en.wikipedia.org/wiki/Depth-first_search[depth-first search] or a link:https://en.wikipedia.org/wiki/Stack_(abstract_data_type)[stack] for link:https://en.wikipedia.org/wiki/Breadth-first_search[breadth-first search].

The choice depends of the type of problem and I don't have a criteria to choose: it something I tweak along.

My last projetc used a FIFO queue so let's use one.

.FiFoQueue.java
[source,java]
----
include::fifoqueue.java[]
----

I use a custom implementation since the code is short and it's only doing what I need.

We can them add the code related to the state lists in the `Level`.

.Level.java
[source,java]
----
include::level2.java[]
----

Calling `State#processState` will add some new possible ``State``s to the list, so the minimal version of the solver loop is now complete.

The last plumbing part is the entry point of the game.

.App.java
[source,java]
----
include::app.java[]
----

The workflow is now completed, and we can now try to (kinda) solve the level:

[source]
----
include::log0.txt[]
----
