= Writing a "`Baba Is You`" solver, part 2: the first level
Julien Kirch
v0.1, 2019-05-05
:article_lang: en
:ignore_files: 
:article_image: first-level.png
:source-highlighter: pygments
:pygments-style: friendly

Following link:../babis-you-1/[the first part], we'll work on solving the first level.

image::first-level.png[title="Here it is"]

The first level has a feature that will simplify things:
the rules can't be changed.

This means that fixed rules can be enough to solve this level, and that the changing rules thingie can be dealt with later.

image::graph1.svg[width=731,height=513]

== First the plumbing

Before dealing with the solving logic, some plumbing is required to establish the game loop.

Most of the code shown here is ported from my previous link:https://github.com/archiloque/rgbexpress[efforts].

First the `Level` class will contain data related to a game level, at first only the information we found in the level, then -- by experience -- we'll add other data that will make the calculations simpler and/or faster.

.Level.java
[source,java]
----
include::level1.java[]
----

Then the `State` will represent a state of the game being solved.
It will follow the same path as the `Level`: it starts as a small class with few attributes (the current status of the game and a pointer to the `Level`) and becomes larger as we add features.

.State.java
[source,java]
----
include::state1.java[]
----

To manage the list of states several possibilities are available, like using a link:https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)[FIFO queue] for link:https://en.wikipedia.org/wiki/Depth-first_search[depth-first search] or a link:https://en.wikipedia.org/wiki/Stack_(abstract_data_type)[stack] for link:https://en.wikipedia.org/wiki/Breadth-first_search[breadth-first search].

The choice depends of the type of problem and I don't have a criteria to choose: it something I tweak along.

My last projetc used a FIFO queue so let's use one.

.FiFoQueue.java
[source,java]
----
include::fifoqueue.java[]
----

I use a custom implementation since the code is short and it's only doing what I need.

We can them add the code related to the state lists in the `Level`.

.Level.java
[source,java]
----
include::level2.java[]
----

Calling `State#processState` will add some new possible ``State``s to the list, so the minimal version of the solver loop is now complete.

The last part is the entry point of the game.

.App.java
[source,java]
----
include::app.java[]
----

The workflow is now completed, and we can now try to (kinda) solve the level:

[source]
----
include::log0.txt[]
----

== And now some logic

It's time to add some logic in the code to make good use of all this plumbing.

=== First: how to solve a level

Each turn we consider a game state, from it there is _at most_ four possible moves: going up, down, right or left.

At most because some direction can be blocked, things can kill you (not in the first level), or you can alter a rule and stop to control anything (not in the first level either).

If you can go in a direction, you may reach a winning state, in this case we stop the solving.

If you don't solve the level, you can add this new state to the list, and go on with the main loop.

There's a catch: Baba is not a "`burning bridge`" game where you can't move back.
Before checking if a new state is interesting, it must be vetted against the previously met cases to avoid doing the same thing again and again.

image::graph2.svg[width=681,height=505,title="The inner algo"]

== Second: how to represent a level
