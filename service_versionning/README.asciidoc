= Gérer les évolutions des services dans votre SI
:toc:

== On parle de quoi

Sous-titre "Versionner les services dans votre SI ça ne veut pas dire modifier une configuration de /v1/ à /v2/"

=== Services à l'intérieur d'un SI

Consommateur et producteur à l'intérieur

Gestion des évolutions : on ne parle pas de comment designer vos services : n'explique pas comment faire du REST

Exposer un service c'est un contrat avec un engagement

=== Objectif d'une bonne gestion

* Pouvoir introduire de nouvelles versions pour répondre aux nouvelles demandes
* Décomissionner les anciennes versions
* Un pur sujet de management de SI
* Sujet très compliqué, peu s'en sortent bien
* Pas de silver bullet où de pattern qu'il suffit de dérouler : quelques pratiques à éviter, et beaucoup de choses à décider pour vous

=== On va parler de mots qui fâchent : gouvernance, planning, budget

`Mettre des exemples`

== Généralités

=== Différence entre modèle "vendeur" et modèle "acheteur"

* En interne : les clients demandent (acheteurs)
* En public : on propose un service aux clients (vendeur)
* En interne : on est sur les deux
** Dans le cas de projets de tailles équivalentes, si pas d'énorme projet qui écrase tout
** Important : connaitre ses consommateurs
* Partenaires : souvent entre les deux, voire encore plus compliqué qu'en interne

=== On parle beaucoup des géants du web mais ils ne sont pas le bon exemple pour les API internes

* Ils parlent peu de ce sujet : plutôt API publiques et implémentation
* Différence dans la complexité du produits entre les géant du web et certains de nos clients : beaucoup plus de dépendances sur des choses plus complexes

=== Différences entre API externes et internes

* Contractualisation beaucoup plus faible
** Un DSI  va faire un optimum global
** En général : engagement moral, pas de pénalité en cas de soucis
*** Au pire on négocie une extension de budget
** En général en interne, si un consommateur n'est pas prêt, on ne va pas le débrancher

== Principes

=== Il faut décider qui décide et comment on décide : DSI, instance de gouvernance ...

* Pas subir la non décision
* Axe décisions : optimum global / privilégier certains projets / ... : arbitrer
* Ça peut dépendre des projets (pas forcément une règle unique), et changer dans la vie des projets
* Ce qu'il faut éviter c'est le flou : une mauvaise stratégie c'est mieux qu'une stratégie floue
* Penser aux projets en TMA

=== Deux forces opposées

* Minimum de changement de versions pour ceux que les nouvelles fonctionnalités n'intéresse pas
* Beaucoup de changements de versions pour ceux que ça intéresse
* Les projets peuvent basculer de l'un à l'autre

== Ce qu'il faut exposer, ou pas

=== Plus on expose plus on créé d'adhérence

* Moins on expose moins on en créé

=== N'exposez pas tout par défaut (toutes les données, tous les champs) : faite le en progressif

=== Limiter les consommateurs tant que votre API n'est pas sèche

=== Faites attention quand vous exposer les données que vous même consommez ou vous créez des cascades de dépendances

* Si j'utilise les données de l'appli A, et même si je dois les stocker, je ne les republie pas, sinon je dois changer les services que j'expose quand A change les siens, ou alors je créé une divergence

=== Royaume émissaire

* Certaines données ont vocation à rester dans une certaine zone métier, ne les déversez pas dans tout le SI

=== Ne pas lier l'exposition avec la représentation interne
* On est capable de ne pas changer l'API même si l'interne n'évolue pas

=== Importance de savoir qui utilise quoi : il faut du monitoring

image::zones.png[title="Les zones de services"]

== Comment exposer

=== Nombre de versions
* Arbitrage entre travail pour le producteur et pour les consommateurs
* Deux (idéal) ou trois versions en parallèle
** Chevauchement temporaire entre deux version (on attend entre la sortie de la N+1 et le décomissionnement de la N-1) : permet de sauter une version sur deux pour les consommateurs

image::versions.png[title="Un exemple de gestion de version"]

=== Quand et quoi communiquer

* Cas idéal : définir le contrat en commnun
* Au minimum : communiquer dès que l'interface a été définie
* Contrat d'API : interface  + données d'exemples + mocks
** Mocks des consommateurs pour tester
** S'outiller (swagger)

=== Compatibilité gérée par l'API Management ou l'ESB

* Pas magique : on change de version majeure c'est qu'on change le comportement métier
* Code métier dans un middleware qui est souvent géré par une équipe qui ne connait pas le métier
* L'équipe du middleware devient le goulot d'étranglement pour les projets qui veulent évoluer

=== Changements rétro-compatibles qui devraient être "transparents" pour éviter une montée de version
* Peut être une bonne idée
* Peut être dangereux quand on le pousse trop loin : risque de tordre les contrats
** Si tu as peur de changer le contrat, c'est qu'il y a problème
* Demande de très bien communiquer

== À quel rythme ?

=== Pas de solution miracle : question à laquelle vous devez répondre vous même

=== Ça depénd des projets et ça peut changer dans la vie des projets

=== Deux stratégies

* Cadencé : une fois tous les X mois
** Rythme de modification de l'API n'est pas le rythme de livraison de projet
**  Plus prévisible pour les consommateurs, permet de s'organiser et de préprovisionner
*** Ça aide d'avoir une roadmap
*** Principe de moindre surprise
* Opportuniste : quand vous en avez besoin
**   Permet plus de fluidité

=== Royaume / émissaire API à deux vitesses

* les services qui sont pour le royaumes peuvent bouger rapidement
** d'ailleurs ils ont tendance à bouger ensemble
* les services qui sont pour tout le SI bouger à un rythme plus lent

=== Si un projet client qui ne peut pas évoluer

* s'il faut maintenir une version spécifique, faire migrer tous les autres
* Coût continu, et qui va augmenter au fur et à mesure que votre interface va évoluer
** Ils paient

== Budget

Une fois toutes les bonnes résolutions prises, reste une question, probablement la plus importante : qui paie ?

Comme dans certains des autres sujets traités, il n'y a pas de réponse qui convienne dans tous les cas.
La différence ici c'est qu'il vaut peut-être mieux choisir une même approche pour tous les projets pour limiter le nombre de fois où on se pose la question.
Les prises de décisions sur les questions de budgets étant extrêmement difficiles, cela permet de limiter les conflits, même si à chaque cycle budgétaire la tentation est grande de tout remettre en cause.

=== Budget des consommateurs

Quand un consommateur de service a besoin de nouvelles fonctionnalités il n'aura pas de soucis à financer la migration vers la nouvelle version d'une API qui va lui fournir ce dont il a besoin.

Les questions de budget se posent quand le consommateur est satisfait de ce qu'il a déjà et qu'il faut migrer à la version suivante.
Le problème se plus particulièrement pour les projets qui sont passé en maintenance, particulièrement en link:https://fr.wikipedia.org/wiki/Tierce_maintenance_applicative[TMA].

Du point du vue du métier, qui a généralement la main sur les questions budgétaire, cette migration n'apporte rien, il est donc logique qu'il soit réticent à dépenser de l'argent pour cela.

Il s'agit du même arbitrage que celui qui se pose pour traiter la dette technique d'un projet, sauf qu'on se place ici au niveau du SI.
Cela rend les choses plus compliqué car les intervenants sont plus nombreux.
Le critère primordial pour choisir une solution n'est pas de fâcher le moins de monde possible, mais de s'assurer que le budget soit là pour que les migrations aient bien lieu en temps et en heure.

Trois approches possibles :

- Si la roadmap du projet qui expose les services est suffisamment claire et prévisible, il est possible de préalouer le coût des migrations dans chaque projet, au même titre que les autres dépenses externes comme l'infrastructure.
- Les consommateurs demandeurs de la nouvelle version peuvent payer pour faire migrer les autres. Cela a pour effet d'augmenter le prix des demandes d'évolutions, donc de les diminuer.
- Un pot commun sous forme d'une taxe "X% du budget" appliquée à tous les consommateurs. Cela permet aux gros projets d'aider à financer les migrations des petits, pour que ceux-ci ne bloquent pas.

Une chose à surveiller dans les deux dernières approches : comme ce n'est pas le projet qui paie, il peut être tentant de gonfler la note, en profitant de la migration pour traiter d'autres sujets.
Sans aller jusqu'à demander de comptes détaillés, gardez donc l'œil ouvert.

=== Budget du projet qui expose les services

Quand un projet expose des services il le fait pour les autres, que ceux-ci contribuent à son budget.

La manière dont les consommateurs financent les évolutions influe sur le rapport du force vis-à-vis du projet :
plus l'un d'entre eux la sentiment de penser d'argent, plus il va vouloir se faire entendre lors des décisions.
Ce n'est pas une mauvaise chose en soit — il est normal que certains projets aient plus d'influence que d'autres —, mais c'est à prendre en compte.

Trois approches :

==== Faire payer les demandeurs d'une évolution

C'est l'approche la plus directe, cependant elle a deux effets secondaires :

- Désavantager les petits projets par rapport aux gros.
- Provoquer une forme d'attentisme : si un projet a besoin d'un nouveau service mais qu'il sait que le projet d'à côté l'a déjà demandé, il a tout intérêt à se taire et à laisser l'autre payer, vu qu'il y aura aussi accès.

Sur ce budget, une part est réservée pour financer la maintenance de l'existant.

=== Un pot commun

Il s'agit de mettre en commun les ressources des différents projets.
Deux axes simples pour la répartition :

- Une taxe "X% du budget";
- Au prorata de la consommation de service (au nombre d'appel).

La première alternative désavantage les gros projets s'ils utilisent peu les services.
La deuxième paraît plus juste du point de vue d'une approche service, mais elle ne reflète pas le coût réel pour le projet.

=== Composer les deux

Il est également possible de composer les deux approches :
- faire payer les demandeurs pour les évolutions;
- un pot commun pour la maintenance.

C'est une approche tentante car elle semble plus juste, cependant elle demande de savoir dans quelle case mettre chaque tâche.
Elle peut être intéressante sur des très gros projets en V, où les aspects budgétaires soient suivis de prêts et où la maintenance fait l'objet de chantiers spécifiques.
Cependant dans des projets plus petits et agiles qui ont appris à refactorer en permanence, mieux vaut une approche plus basique qui évitera de bureaucratiser le projet.
